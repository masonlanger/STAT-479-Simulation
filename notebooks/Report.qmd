---
title: "2019-2020 UEFA Champions League Simulation"
output: html
author:
  - name: Mason Langer
  - name: Hazim Izani
  - name: Rohan Ahuja
execute:
  cache: false
  freeze: false
editor_options: 
  chunk_output_type: inline
references:
- id: poisson
  author:
    - name: A. Heurer et. al
  title: "Soccer: Is scoring goals a predictable Poissonian process?"
  journal: "Eur. Phys."
  volume: 89
  number: 3
  type: journal
  issued:
    month: 2
    year: 2010
  url: "https://iopscience.iop.org/article/10.1209/0295-5075/89/38007/pdf"
---

```{r}
#| echo: false
#| include: false
set.seed(439)
RNGkind("Mersenne-Twister", "Inversion", "Rejection")  # Explicit RNG type

require(devtools, quietly = TRUE)
require(tidyverse, quietly = TRUE)
require(reactable)
require(htmltools)
require(data.table)
require(scales)
# devtools::install_github("hturner/BradleyTerry2")
require(BradleyTerry2, quietly = TRUE)
devtools::install_github("hrbrmstr/hrbrthemes", quiet = TRUE)
require(hrbrthemes, quietly = TRUE)
```

## Executive Summary

Like many sports competitions and organizations around the globe in early 2020, UEFA, the governing body of soccer in Europe, decided to postpone the knockout stages of the historic and immensely popular Champions League (UCL) tournament due to the COVID-19 pandemic. When the tournament finally resumed, it did so in a modified format: UEFA elected to change the typical competition format from a two game, home-and-away series in the quarterfinal and semifinal rounds, to a single elimination format. Further, games only took place at a neutral site for both teams, with all of the remaining games being played in Porto, Portugal. After all of the changes and with the pandemic still affecting society at large, the German powerhouse of Bayern Munich won the 2019-2020 Champions League tournament, besting a Paris Saint-Germain (Paris S-G or PSG) team with superstars like Angel Di Maria, Neymar, and Kylian Mbappe 1-0[^1]. 

Therefore, this iteration of the Champions League presents an interesting challenge in itself: do the results of the 2019-20 Champions League align with the expectations of the tournament, should it have been played in its traditional two-leg format? Thus, throughout our project, we sought to simulate the tournament from the quarterfinals through the final with its typical format and analyze the results to see who won and what differed from the actual tournament's match-ups and winners. 

Our models used the ideas of domestic strength and home-field advantage to inform team strengths for participants in the UCL. Domestic strength was defined as a team's performance relative to their domestic components, while home-field advantage was the associated "boost" to a UCL team in the group stages of the tournament when they played on their home pitch,

Instead of beginning our project at the quarterfinal stage, we wanted to simulate a round that wasn't impacted by the COVID-19 pandemic. Thus, we started our project with simulating the round of 16, where we simulated the goals scored for each team, which we could then use to determine a winner and a probability that a given team advanced. These initial results saw strong deviations from the actual results, with teams like Juventus being predicted to have a 99% chance of advancing, while they lost to Lyon in real life.

After this initial case study, we pivoted to simulating only the quarterfinals through the final round. In these simulations, which were based on three different underlying models, we saw some comparable and some divergent results. Primarily, between the three models, we saw PSG favored to win the tournament, instead of the actual winners, Bayern Munich. However, our models suggested different final and semifinal match-ups, with one suggesting Spanish-side FC Barcelona would play PSG in the final, while another accurately projected the semifinal and final match-up confidently. With that said, from our results, we can draw that in an alternative path where UEFA did not modify the Champions League format, PSG, the actual runner-ups in the 2019-20 tournament, would've been the favorites.

[^1]: <https://www.uefa.com/uefachampionsleague/match/2030150--paris-vs-bayern-munchen/>

## Data Overview
The following data was gathered using the `worldfootballR` library to scrape 2019-20 UEFA Champions League group stage and knockout game results and the 2018-19 domestic league results for the 32 competing teams across 16 individual league competitions[^2] from [fbref.com](https://www.fbref.com).

[^2]: Members from the following domestic leagues took part in the 2019-20 UEFA Champions League group stage: *Austrian Football Bundesliga, Belgian Pro League, Croatian Football League, Czech First League, English Premier League, French Ligue 1, German Fusball Bundesliga, Greek Super League, Italian Serie A, Dutch Eredivise, Portugese Premeira Liga, Russian Premier League, Serbian SuperLiga, Spanish La Liga, Turkish Super Lig, Ukrainian Premier League*

```{r}
#| echo: false
#| include: FALSE
## Read in all league results
austria = readr::read_csv('../data/raw/Austria_Austrian_Football_Bundesliga_2018-19.csv', show_col_types = FALSE)
belgium = readr::read_csv('../data/raw/Belgium_Belgian_Pro_League_2018-19.csv', show_col_types = FALSE)
croatia = readr::read_csv('../data/raw/Croatia_Croatian_Football_League_2018-19.csv', show_col_types = FALSE)
czech = readr::read_csv('../data/raw/Czechia_Czech_First_League_2018-19.csv', show_col_types = FALSE)
england = readr::read_csv('../data/raw/England_Premier_League_2018-19.csv', show_col_types = FALSE)
france = readr::read_csv('../data/raw/France_Ligue_1_2018-19.csv', show_col_types = FALSE)
germany = readr::read_csv('../data/raw/Germany_Fusball_Bundesliga_2018-19.csv', show_col_types = FALSE)
greece = readr::read_csv('../data/raw/Greece_Super_League_Greece_2018-19.csv', show_col_types = FALSE)
italy = readr::read_csv('../data/raw/Italy_Serie_A_2018-19.csv', show_col_types = FALSE)
nether = readr::read_csv('../data/raw/Netherlands_Eredivise_2018-19.csv', show_col_types = FALSE)
portugal = readr::read_csv('../data/raw/Portugal_Premeira_Liga_2018-19.csv', show_col_types = FALSE)
russia = readr::read_csv('../data/raw/Russia_Russian_Premier_League_2018-19.csv', show_col_types = FALSE)
serbia = readr::read_csv('../data/raw/Serbia_Serbian_SuperLiga_2018-19.csv', show_col_types = FALSE)
spain = readr::read_csv('../data/raw/Spain_La_Liga_2018-19.csv', show_col_types = FALSE)
turkey = readr::read_csv('../data/raw/Turkiye_Super_Lig_2018-19.csv', show_col_types = FALSE)
ukraine = readr::read_csv('../data/raw/Ukraine_Ukrainian_Premier_League_2018-19.csv', show_col_types = FALSE)
```

## Data Pre-processing

In order to use the domestic competition and UEFA Champions League matchup data scraped from [fbref.com](https://www.fbref.com/)[^3] with the Bradley-Terry package, `BradleyTerry2`, the raw data must first be cleaned, parsed, and reformated into the package's expected format. This code follows that found in Lecture 12, particularly when refactoring home and away win data into a trainable DataFrame.

[^3]: Specific links and FBRef pages used can be found in the *GettingRawMatchupData.Rmd* notebook at [our GitHub repo](https://github.com/masonlanger/STAT-479-Simulation).

```{r}
#| include: false
# Helper to remove xG columns from relevant leagues so all competitions have the same number of columns

remove_xg = function(df){ 
  if((df %>% select(contains('_xG')) %>% length()) > 0){
    return(df %>% select(-contains('_xG')))
  }
  else {
    return(df)
  }
}
austria = remove_xg(austria)
belgium = remove_xg(belgium)
croatia = remove_xg(croatia)
czech = remove_xg(czech)
england = remove_xg(england)
france = remove_xg(france)
germany = remove_xg(germany)
greece = remove_xg(greece)
italy = remove_xg(italy)
nether = remove_xg(nether)
portugal = remove_xg(portugal)
russia = remove_xg(russia)
serbia = remove_xg(serbia)
spain = remove_xg(spain)
turkey = remove_xg(turkey)
ukraine = remove_xg(ukraine)

# Concatenate all leagues together
all = austria %>%
  rbind(belgium) %>%
  rbind(croatia) %>%
  rbind(czech) %>%
  rbind(england) %>%
  rbind(france) %>%
  rbind(germany) %>%
  rbind(greece) %>%
  rbind(italy) %>%
  rbind(nether) %>%
  rbind(portugal) %>%
  rbind(russia) %>%
  rbind(serbia) %>%
  rbind(spain) %>%
  rbind(turkey) %>%
  rbind(ukraine)
all %>% head(10)
```

With the leagues all concatenated together, we can check to see the distribution of the complete DataFrame's members.

```{r}
#| echo: false
set.seed(439)
all[sample(1:nrow(all), size=10),]
```

```{r}
#| echo: false
matches_by_country = all %>%
                        group_by(Country) %>%
                        count(.drop = TRUE)

plot = ggplot2::ggplot(matches_by_country, aes(matches_by_country$Country, matches_by_country$n)) + 
  ggplot2::geom_col() + 
  labs(title = "2018-19 Domestic League Matches By Competing Nation", x = "UEFA Country", y = "Number of Matches") + 
  hrbrthemes::theme_ipsum(grid="Y")
plot
```

```{r}
#| echo: false
no_ties = all %>% filter(HomeGoals != AwayGoals) %>%
  filter(!str_detect(Round, "play-offs") | is.na(Round)) %>% ## removing matchups in pro/rel playoffs, otherwise we'll see skewed strengths for those leagues
  mutate(Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),
         Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))

unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))

results = no_ties %>% 
  rename(home.team = Home, away.team = Away) %>%
  group_by(home.team, away.team) %>%
  dplyr::summarise(
    home.win = sum(Home_Winner),
    away.win = sum(Opp_Winner), .groups = 'drop') |>
  dplyr::mutate(
    home.team = factor(home.team, levels = unik_teams),
    away.team = factor(away.team, levels = unik_teams))
results[sample(1:nrow(results),size=10),]
```

With the data now in place and formatted for `BradleyTerry2`, we can begin fitting a Bradley-Terry model to determine latent team strength for all clubs competing in the 2019-20 UEFA Champions League group stage based on their domestic league results.

## Fitting Bradley-Terry Model Based on Domestic League Results

For this problem, we'll use a weak baseline as a reference, which we found to best fit the team strengths without many missing values, due to disconnected graphs.

Throughout our trials, we found that the Russian team Yenisey, which placed 16th out of 16 teams in the Russian Premier League throughout the 2018-19 season, resulted in a well-defined range of team strengths.[^4]

[^4]: <https://en.wikipedia.org/wiki/2018%E2%80%9319_Russian_Premier_League#League_table>

```{r}
#| collapse: true
fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    refcat = "Yenisey",
    data = results)
summary(fit)
```

```{r}
lambda_hat = as.data.frame(BradleyTerry2::BTabilities(fit))
lambda_hat = lambda_hat %>% drop_na() %>% arrange(desc(ability))
lambda_hat = rownames_to_column(lambda_hat) %>% rename(team = rowname)
lambda_hat
```

Given the summary of the Bradley-Terry model and its resulting team strengths, it seems that the results were relatively sensitive to positive results for teams in skewed competitions. In other words, in leagues that are typically dominated by a small number of teams (Greece, Czechia), results over and by the top teams in the competitions were "rewarded" more than their counterparts in other "fairer" competitions (England, Spain). Subjectively, clubs like Red Star typically dominant their domestic competition, which means we would expect a high "ability" assignment, like we see in this model.

For the sake of our project, we'll only focus on the strengths of the clubs competing in the 2019-20 UEFA Champions League group stages. From this, we see the aforementioned Red Star leading in "domestic strength", along with other dominant teams from smaller nations, like Olympiacos from Greece and Dinamo Zagreb from Croatia. This aligns with our prior assumptions.

```{r}
#| echo: false
uefa = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types=FALSE) 

uefa = uefa %>% select(Home) %>% mutate(Country = str_extract(uefa$Home, " [a-z]{2,3}$"), Home = str_remove(uefa$Home, " [a-z]{2,3}$")) %>% select(Home, Country, everything())

champs_w_league_ratings = uefa %>% left_join(lambda_hat %>% rename(Home = team), by='Home') %>% unique() %>% replace(is.na(.), 0)

champs_w_league_ratings %>% arrange(desc(ability))
```

```{r}
#| echo: false
strongest = champs_w_league_ratings %>% arrange(desc(ability)) %>% head(5)

plot = ggplot2::ggplot(strongest, aes(Home, ability)) + 

  ggplot2::geom_col() + 

  labs(title = "Top 5 Teams by 2018-19 Domestic Performance Strength", x = "Club", y = "Team Strength λ") + 

  hrbrthemes::theme_ipsum(grid="Y")

plot
```

## Starting Out: Using Markov Chains to Simulate Round of 16

While our project is focused primarily on rounds past the Round of 16, we still wanted to have a baseline understanding of simulating the UEFA Champions League competition. Therefore, we elected to simulate the Round of 16 based on real life match-ups. However, unlike our models described later in this report, we did not use a Bradley-Terry + binomial simulation. Instead, to observe and analyze the differences between modelling and simulation methodologies, we pursued a simulation using Markov Chains.

```{r}
#| code-fold: true
#| code-summary: Data manipulation for Markov chain simulation
ucl = readr::read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types = FALSE)
ucl = ucl %>%  
  mutate(
    Country_Away = str_extract(Away, "^[A-Za-z]{2,3}(?=\\s)"),
    Country_Home = str_extract(ucl$Home, " [a-z]{2,3}$")
  ) %>%
  mutate(
    Home = stringr::str_remove(Home, " [a-z]{2,3}$"),
    Away = str_remove(Away, "^[A-Za-z]{2,3}\\s+")
  )

uefa_playoff_teams = ucl %>%
  filter(Round %in% c("Round of 16", "Quarter-finals", "Semi-finals", "Final")) %>% select(Home, Away) %>%
  unlist(use.names = FALSE) %>% unique() 

ucl_group <- ucl %>%
  filter(Round == "Group stage", HomeGoals != AwayGoals)

ucl_teams <- sort(unique(c(ucl_group$Home, ucl_group$Away)))

domestic_restricted <- all %>%
  mutate(Home = as.character(Home), Away = as.character(Away)) %>%
  filter(Home %in% ucl_teams | Away %in% ucl_teams) %>%
  filter(HomeGoals != AwayGoals) %>%
  filter(!stringr::str_detect(Round, "play-offs") | is.na(Round))
wt_ucl = 8
wt_dom = 1

bt_dom <- domestic_restricted %>%
  transmute(
    home.team = Home,
    away.team = Away,
    home.win  = as.integer(HomeGoals > AwayGoals),
    away.win  = as.integer(AwayGoals > HomeGoals),
    Competition = "Domestic"
  )

bt_ucl <- ucl_group %>%
  transmute(
    home.team = Home,
    away.team = Away,
    home.win  = as.integer(HomeGoals > AwayGoals),
    away.win  = as.integer(AwayGoals > HomeGoals),
    Competition = "UCL"
  )

bt_all <- bind_rows(bt_dom, bt_ucl) %>%
  mutate(w = ifelse(Competition == "UCL", wt_ucl, wt_dom))

unik_teams_all <- sort(unique(c(bt_all$home.team, bt_all$away.team)))
bt_all <- bt_all %>%
  mutate(
    home.team = factor(home.team, levels = unik_teams_all),
    away.team = factor(away.team, levels = unik_teams_all)
  )


```

Fitting the BT model, we get:

```{r}
#| echo: false
#| collapse: true
fit_all = BradleyTerry2::BTm(
  outcome = cbind(home.win, away.win),
  player1 = home.team,
  player2 = away.team,
  refcat = "Yenisey", 
  data = bt_all
)

lambda_hat_combined <- BradleyTerry2::BTabilities(fit_all) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("team") %>%
  arrange(desc(ability))

lambda_hat_combined = lambda_hat_combined %>%
  filter(team %in% uefa_playoff_teams)

lambda_hat_combined
```

From the results, we see that Juventus, Liverpool, and Barcelona are at the top of the ability category. These teams all had strong rosters and strong domestic results as well as group stage results. At the bottom, as expected we see teams less prestigious like Atalanta and Valencia. The standard error is all the same, which is because since all the teams didn't play each other for example Bayern never played Valencia, so we get disconnected graphs. For this round of 16 simulation, this doesn't make a huge deal.

```{r}
#| echo: false
lambda_hat_combined %>% 
  slice_max(ability, n = 10) %>%
  ggplot(aes(reorder(team, ability), ability)) +
  geom_col() + coord_flip() +
  labs(title="Top BT Strengths (Domestic+UCL Group Stage(Group match weights 8x))", x=NULL, y="Ability (β)") +
  theme_minimal()
```

Since the round of 16 for the Champions League Tournament had 2 legs before COVID officially shut down the tournament, we need to simulate both legs of the contest. However our Bradley-Terry model has limitations where it doesn't predict score just the overall winner. For 2 leg contests, this shows a problem where aggregate score decides the winner. If both teams win one game, the Bradley Terry model doesn't know who wins the whole round. Also, if one team wins marginally, and the other team wins by a lot, it still looks like 1 win and 1 loss to the Bradley Terry model. This is the reason that we want to get the scores of the matchups, so we shift for this round specifically to a Markov Chain model modeling states of the games using the Bradley-Terry strengths to simulate goal scores and state changes.

```{r}
total_gpm <- 2.7   # constant, estimated how many goals are scored per game
beta      <- 0.9   # how strongly BT ability difference tilts scoring share
hfa       <- 0.28  # home-field advantage in the scoring-share logit
et_scale  <- 0.75  # scoring slows in extra time
set.seed(25)

inv_logit <- function(x) 1/(1+exp(-x))

lambda_vec_raw <- setNames(lambda_hat_combined$ability, lambda_hat_combined$team)

get_lambda <- function(team) {#helper to get BT scores
  if (!is.na(team) && team %in% names(lambda_vec_raw)) {
    lambda_vec_raw[[team]]
  } else {
    0
  }
}

r16_ties <- tibble::tribble(
  ~tie_id, ~home_first_leg,     ~away_first_leg,
  "R16-1", "Atalanta",          "Valencia",
  "R16-2", "Dortmund",          "Paris S-G",
  "R16-3", "Atletico Madrid",   "Liverpool",
  "R16-4", "Tottenham",         "RB Leipzig",
  "R16-5", "Chelsea",           "Bayern Munich",
  "R16-6", "Napoli",            "Barcelona",
  "R16-7", "Real Madrid",       "Manchester City",
  "R16-8", "Lyon",              "Juventus"
)

r16_ties
```

```{r}
#| code-fold: true
#| code-summary: Helper methods for Markov chain and Monte Carlo simulation
sim_match_markov <- function(Home, Away, neutral=FALSE, allow_et=TRUE) {
  lamH <- get_lambda(Home); lamA <- get_lambda(Away)
  r_tot <- total_gpm / 90   # goal p per min
  s_home <- inv_logit(beta * (lamH - lamA) + ifelse(neutral, 0, hfa))
  pH <- r_tot * s_home
  pA <- r_tot * (1 - s_home)
  #first 90 mins
  gH <- 0L; gA <- 0L
  for (t in 1:90) {
    u <- runif(1)
    if (u < pH) gH <- gH + 1L else if (u < pH + pA) gA <- gA + 1L
  }
  
  #extra time - scale p to show scoring in ET
  if (allow_et && gH == gA) {
    pH_et <- pH * et_scale; pA_et <- pA * et_scale
    for (t in 1:30) {
      u <- runif(1)
      if (u < pH_et) gH <- gH + 1L else if (u < pH_et + pA_et) gA <- gA + 1L
    }
    if (gH == gA) {
      # Penalties 
      base <- 0.76; tilt <- 0.02 #tilt nudges odds towards stronger team
      p_home <- max(min(base + tilt * tanh(lamH - lamA), 0.95), 0.55)
      p_away <- max(min(base - tilt * tanh(lamH - lamA), 0.95), 0.55)
      a <- b <- 0L
      for (i in 1:5) { a <- a + rbinom(1,1,p_home); b <- b + rbinom(1,1,p_away) }
      if (a != b) return(list(gH=gH, gA=gA, mode="PK", winner=ifelse(a>b,"home","away")))
      repeat {
        aa <- rbinom(1,1,p_home); bb <- rbinom(1,1,p_away)
        if (aa != bb) return(list(gH=gH, gA=gA, mode="PK", winner=ifelse(aa>bb,"home","away")))
      }
    }
    return(list(gH=gH, gA=gA, mode="ET", winner=ifelse(gH>gA,"home","away")))
  }
  list(gH=gH, gA=gA, mode="FT", winner=ifelse(gH>gA,"home","away"))
}

sim_two_leg_markov <- function(A, B, away_goals_rule=TRUE) {
  # Leg 1: A home
  L1 <- sim_match_markov(A, B, neutral=FALSE, allow_et=FALSE)
  # Leg 2: B home
  L2 <- sim_match_markov(B, A, neutral=FALSE, allow_et=FALSE)

  aggA <- L1$gH + L2$gA
  aggB <- L1$gA + L2$gH
  if (aggA != aggB) return(list(winner=ifelse(aggA>aggB, A, B),
                                aggA=aggA, aggB=aggB, decided="AGG"))
  if (away_goals_rule) {
    A_away <- L2$gA; B_away <- L1$gA
    if (A_away != B_away)
      return(list(winner=ifelse(A_away>B_away, A, B),
                  aggA=aggA, aggB=aggB, decided="AWAY_GOALS"))
  }
  # ET in Leg 2 (B home)
  lamB <- get_lambda(B); lamA <- get_lambda(A)
  r_tot <- total_gpm / 90
  s_home <- inv_logit(beta * (lamB - lamA) + hfa)
  pH_et <- (r_tot * s_home) * et_scale
  pA_et <- (r_tot * (1 - s_home)) * et_scale
  gH_et <- 0L; gA_et <- 0L
  for (t in 1:30) {
    u <- runif(1)
    if (u < pH_et) gH_et <- gH_et + 1L else if (u < pH_et + pA_et) gA_et <- gA_et + 1L
  }
  aggA2 <- aggA + gA_et
  aggB2 <- aggB + gH_et
  if (aggA2 != aggB2)
    return(list(winner=ifelse(aggA2>aggB2, A, B),
                aggA=aggA2, aggB=aggB2, decided="ET"))

  # PKs
  base <- 0.76; tilt <- 0.02
  p_home <- max(min(base + tilt * tanh(lamB - lamA), 0.95), 0.55)
  p_away <- max(min(base - tilt * tanh(lamB - lamA), 0.95), 0.55)
  a <- b <- 0L
  for (i in 1:5) { a <- a + rbinom(1,1,p_home); b <- b + rbinom(1,1,p_away) }
  if (a != b) return(list(winner=ifelse(a>b, B, A),
                          aggA=aggA2, aggB=aggB2, decided="PK"))
  repeat {
    aa <- rbinom(1,1,p_home); bb <- rbinom(1,1,p_away)
    if (aa != bb) return(list(winner=ifelse(aa>bb, B, A),
                              aggA=aggA2, aggB=aggB2, decided="PK"))
  }
}

simulate_r16_mc <- function(N=5000, away_goals_rule=TRUE) {
  purrr::map_dfr(seq_len(nrow(r16_ties)), function(i) {
    A <- r16_ties$home_first_leg[i]
    B <- r16_ties$away_first_leg[i]
    winsA <- 0L; sumAggA <- 0; sumAggB <- 0
    for (k in 1:N) {
      out <- sim_two_leg_markov(A, B, away_goals_rule=away_goals_rule)
      if (out$winner == A) winsA <- winsA + 1L
      sumAggA <- sumAggA + out$aggA
      sumAggB <- sumAggB + out$aggB
    }
    pA <- winsA / N
    tibble::tibble(
      tie_id = r16_ties$tie_id[i],
      team_A = A, team_B = B,
      p_adv_A = pA,
      p_adv_B = 1 - pA,
      se_A = sqrt(pA*(1-pA)/N),
      mean_agg_A = sumAggA / N,
      mean_agg_B = sumAggB / N
    )
  }) %>% arrange(tie_id)
}
```

Now, we'll run a Markov simulation to get the probability a team will win out of N times, which also gets the average aggregate scores between two teams. This shows us how many times a team would be expected to win based on our BT strengths and the tie's match-up.

```{r}
N <- 5000
r16_results <- simulate_r16_mc(N=N, away_goals_rule=TRUE)
print(r16_results)
```

From the Monte Carlo results, we see that: - Atalanta is favored over Valencia slightly, reflecting Atalanta's win in real life. - Dortmund is heavily favored over PSG, which was wrong by the model, the BT including the group stage ranked PSG very low which was interesting - Liverpool is heavily favored over Atlético Madrid, similar to real life where an upset happened and Atlético Madrid pulled out the victory - Leipzig is favored 0.7 to 0.3 to Tottenham, aligning with real life - Bayern is favored 0.8 to 0.2, aligning with real life where Bayern won - Barcelona is favored 0.7 to 0.3 to Napoli, where Barcelona pulled out the win - Manchester City was heavily favored against Real Madrid, 0.9 to 0.1 where Manchester City won in real life - With the biggest upset, Lyon won in real life vs Juventus, which is 0.99 percent to win showing a large upset from our model's expectation

```{r}
#| echo: false
r16_long <- r16_results %>%
  mutate(matchup = paste(team_A, "vs", team_B)) %>%           # <-- create it
  pivot_longer(
    cols = c(mean_agg_A, mean_agg_B),
    names_to = "which_team",
    values_to = "mean_goals"
  ) %>%
  mutate(team = if_else(which_team == "mean_agg_A", team_A, team_B)) %>%
  select(tie_id, matchup, team, mean_goals)



# Plot: side-by-side bars per matchup
ggplot(r16_long, aes(x = matchup, y = mean_goals, fill = team)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_text(aes(label = round(mean_goals, 2)),
            position = position_dodge(width = 0.7),
            vjust = -0.25, size = 3) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.08))) +
  labs(title = "R16: Average Goals by Team (Markov simulations)",
       x = "Matchup", y = "Average Goals", fill = "Team") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 25, hjust = 1))

```

```{r}
#| echo: false
r16_long <- r16_results %>%
  transmute(
    tie_id,
    team_A, team_B,
    p_A = p_adv_A,
    p_B = p_adv_B
  ) %>%
  pivot_longer(cols = c(team_A, team_B),
               names_to = "side", values_to = "team") %>%
  mutate(prob = ifelse(side == "team_A", p_A, p_B)) %>%
  mutate(prob_cap50 = pmin(prob, 0.5),
         label_full = sprintf("%.1f%%", 100 * prob))


ggplot(r16_long, aes(x = tie_id, y = prob_cap50, fill = team)) +
  geom_col(position = position_dodge(width = 0.65), width = 0.6) +
  geom_text(aes(label = label_full),
            position = position_dodge(width = 0.65),
            vjust = -0.25, size = 3.2) +
  scale_y_continuous(labels = percent_format(accuracy = 1),
                     limits = c(0, 0.5), breaks = seq(0, 0.5, by = 0.1)) +
  labs(
    title = "R16: Win Probabilities (Each Team Capped at 50%)",
    x = "Tie",
    y = "Probability (capped at 50%)",
    fill = "Team"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

```{r}
#| code-fold: true
#| code-summary: More helpers for Markov chain simulations
#helper to simulate match using markov function
play_neutral <- function(A, B) {
  out <- sim_match_markov(Home = A, Away = B, neutral = TRUE, allow_et = TRUE)
  if (out$winner == "home") A else B
}

simulate_tournament_once <- function(r16_results) {
  winners_r16 <- r16_results %>%
    arrange(tie_id) %>%                 
    mutate(
      A_wins = runif(n()) < p_adv_A,
      winner = ifelse(A_wins, team_A, team_B)
    )

  qf1_A <- winners_r16$winner[winners_r16$tie_id == "R16-1"]
  qf1_B <- winners_r16$winner[winners_r16$tie_id == "R16-2"]

  qf2_A <- winners_r16$winner[winners_r16$tie_id == "R16-3"]
  qf2_B <- winners_r16$winner[winners_r16$tie_id == "R16-4"]

  qf3_A <- winners_r16$winner[winners_r16$tie_id == "R16-5"]
  qf3_B <- winners_r16$winner[winners_r16$tie_id == "R16-6"]

  qf4_A <- winners_r16$winner[winners_r16$tie_id == "R16-7"]
  qf4_B <- winners_r16$winner[winners_r16$tie_id == "R16-8"]

  qf1_w <- play_neutral(qf1_A, qf1_B)
  qf2_w <- play_neutral(qf2_A, qf2_B)
  qf3_w <- play_neutral(qf3_A, qf3_B)
  qf4_w <- play_neutral(qf4_A, qf4_B)

  
  sf1_w <- play_neutral(qf1_w, qf2_w)
  sf2_w <- play_neutral(qf3_w, qf4_w)

  
  champion <- play_neutral(sf1_w, sf2_w)

  list(
    champion = champion,
    final_A = sf1_w,
    final_B = sf2_w
  )
}

simulate_tournament_field <- function(M = 5000, r16_results) {
  champs   <- character(M)
  finals_A <- character(M)
  finals_B <- character(M)

  for (m in seq_len(M)) {
    sim <- simulate_tournament_once(r16_results)
    champs[m]   <- sim$champion
    finals_A[m] <- sim$final_A
    finals_B[m] <- sim$final_B
  }

  sims <- tibble::tibble(
    sim_id  = seq_len(M),
    champion = champs,
    final_A  = finals_A,
    final_B  = finals_B
  )

  
  title_probs <- sims %>%
    dplyr::count(champion, name = "titles") %>%
    dplyr::mutate(
      total_sims = sum(titles),
      pct = titles / total_sims
    ) %>%
    dplyr::arrange(dplyr::desc(pct))

  final_matchups <- sims %>%
    dplyr::mutate(
      team1 = pmin(final_A, final_B),
      team2 = pmax(final_A, final_B)
    ) %>%
    dplyr::count(team1, team2, name = "n") %>%
    dplyr::mutate(
      total_sims = sum(n),
      pct = n / total_sims
    ) %>%
    dplyr::arrange(dplyr::desc(pct))

  list(
    title_probs    = title_probs,
    final_matchups = final_matchups,
    raw_sims       = sims
  )
}

set.seed(25)
M <- 5000
tourn_out <- simulate_tournament_field(M, r16_results)

tourn_out$title_probs       
tourn_out$final_matchups    
```

## Fitting Bradley-Terry Model based on Domestic League + UCL Group Stage and Round of 16 results

Now, we'll move on from using Markov chains to using Bradley-Terry models to define latent team strengths, covariate coefficients, and pairwise probabilities. For these two models, we'll focus on the quarterfinals through the final round, instead of worrying about the round of 16, which wasn't affected by the COVID-19 pandemic.

For this Bradley-Terry model, we fit our lambdas on the domestic league data that we sourced earlier combined with group stage and round of 16 results from the 2019-2020 tournament.

```{r, echo=FALSE}
uefa = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types = FALSE) 

uefa_playoff_teams = c(
  "Atalanta", "RB Leipzig", "Barcelona", "Manchester City",
  "Lyon", "Paris S-G", "Atlético Madrid", "Bayern Munich"
)

uefa_playoff_teams
```

These are the 8 teams that advanced to the semifinals in real life, we'll use these to filter our strengths and compute match-up probabilities once they're defined.

```{r}
#| echo: false
#| include: false
uefa_group_ro16 = uefa %>% filter(Round %in% c("Group stage", "Round of 16"))

uefa_group_ro16
```

```{r}
#| echo: false
#| include: false
#| warning: false
z = colnames(uefa)
z = z[colnames(uefa) %in% colnames(all)]
uefa = uefa %>% select(z)
all_combined = all %>% rbind(uefa)


head(all_combined)
```

```{r}
no_ties_combined = all_combined %>%
  filter(HomeGoals != AwayGoals) %>%
  mutate(Home_Winner = as.numeric(HomeGoals > AwayGoals),
         Opp_Winner  = as.numeric(AwayGoals > HomeGoals))

unik_teams = sort(unique(c(no_ties_combined$Home, no_ties_combined$Away)))

results_combined = no_ties_combined %>%
  rename(home.team = Home, away.team = Away) %>%
  group_by(home.team, away.team) %>%
  summarise(
    home.win = sum(Home_Winner),
    away.win = sum(Opp_Winner),
    .groups = "drop"
  ) %>%
  mutate(
    home.team = factor(home.team, levels = unik_teams),
    away.team = factor(away.team, levels = unik_teams)
  )


fit_all = BTm(
  outcome = cbind(home.win, away.win),
  player1 = home.team,
  player2 = away.team,
  refcat = "Yenisey",
  data = results_combined
)

combined_lambda_hat = as.data.frame(BradleyTerry2::BTabilities(fit_all)) %>%
  rownames_to_column("team") %>%
  arrange(desc(ability))

combined_lambda_hat
```

Above, we get coefficients similar to our domestic strengths, but with significantly smaller standard errors (s.e.) than when we fit our strengths without the group stage and round of 16 results. With that said, a lot of our top performers, as seen above and below, are from the same competitions-namely the top four all come from the Czech league.

```{r}
plot = ggplot2::ggplot(combined_lambda_hat %>% arrange(desc(ability)) %>% head(5), aes(reorder(team, -ability), ability)) + 
  ggplot2::geom_col() + 
  labs(title = "Top 5 Teams by UCL 2019-2020 Group Stage + RO16 Performance Strength", x = "Club", y = "Team Strength λ") 
plot
```

We'll now filter the abilities by quarterfinal participants, where we see PSG placing first, with Barcelona and Manchester City closely following.

```{r}
combined_lambda_hat = combined_lambda_hat %>%
  filter(team %in% uefa_playoff_teams)

combined_lambda_hat %>% arrange(desc(ability))
```

```{r}
strength_plot = combined_lambda_hat %>%
  arrange(desc(ability)) %>%
  ggplot(aes(x = reorder(team, ability), y = ability)) +
  geom_col(fill = "#1f78b4", width = 0.7) +
  geom_text(aes(label = round(ability, 2)),
            hjust = -0.1, size = 4, color = "black") +
  coord_flip(clip = "off") +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.1))
  ) +
  labs(
    title = "Playoff Teams Strengths",
    subtitle = "Bradley–Terry Model Estimated Team Abilities (λ)",
    x = "Team",
    y = "Ability (λ)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold"),
    plot.subtitle = element_text(size = 11, color = "gray30"),
    axis.text.y = element_text(face = "bold"),
    axis.title.y = element_text(vjust = 1),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    plot.margin = margin(10, 40, 10, 10)
  )
strength_plot
```

```{r, echo=FALSE}
avg_goals = uefa %>%
  filter(Round %in% c("Group stage", "Round of 16")) %>%
  mutate(total_goals = HomeGoals + AwayGoals) %>%
  summarise(avg_goals = mean(total_goals, na.rm = TRUE))

avg_goals

quarters = data.frame(
  Hi = c("Atalanta", "RB Leipzig", "Barcelona", "Manchester City"),
  Lo = c("Paris S-G", "Atlético Madrid", "Bayern Munich", "Lyon"),
  stringsAsFactors = FALSE
)
```

#### Simulation

Now, we'll actually simulate the tournament as if it took place over two-legs instead of one, starting at the quarterfinals. In this simulation, in order to break ties where teams "split the series," we use a Poisson distribution defined using *goals for* in the group stage for a particular team to draw a sample representing that team's goals scored. In the real competition, this is defined as an "aggregate" over two legs.

```{r}
# compute win probabilities
possible_matchups = quarters %>%
  dplyr::left_join(combined_lambda_hat %>% dplyr::select(team, ability),
                   by = c("Hi" = "team")) %>%
  dplyr::rename(Hi_ability = ability) %>%
  dplyr::left_join(combined_lambda_hat %>% dplyr::select(team, ability),
                   by = c("Lo" = "team")) %>%
  dplyr::rename(Lo_ability = ability) %>%
  dplyr::mutate(
    # expected goal rate scaling based on relative Bradley-Terry abilities
    Hi_lambda = exp(Hi_ability) / (exp(Hi_ability) + exp(Lo_ability)) * 3.205357,
    Lo_lambda = exp(Lo_ability) / (exp(Hi_ability) + exp(Lo_ability)) * 3.205357
  )

# Helper function for 2-leg tie using aggregate goals
simulate_two_leg_goals = function(ability_hi, ability_lo, avg_goals = 3.205357) {
  # Convert BT abilities into expected goal rates per match
  lambda_hi = exp(ability_hi) / (exp(ability_hi) + exp(ability_lo)) * avg_goals
  lambda_lo = exp(ability_lo) / (exp(ability_hi) + exp(ability_lo)) * avg_goals

  # Simulate goals for each of the two legs 
  # Each team plays two matches, goals ~ Poisson distributed
  leg1_hi = rpois(1, lambda_hi)
  leg1_lo = rpois(1, lambda_lo)
  leg2_hi = rpois(1, lambda_hi)
  leg2_lo = rpois(1, lambda_lo)

  # Aggregate total goals across both legs 
  total_hi = leg1_hi + leg2_hi
  total_lo = leg1_lo + leg2_lo

  # Decide winner based on aggregate goals 
  if (total_hi > total_lo) {
    return(1)  # Hi team advances
  } else if (total_lo > total_hi) {
    return(0)  # Lo team advances
  } else {
    # Tie after two legs
    # Compute win probability based on relative abilities
    prob_hi_wins_tiebreak = exp(ability_hi) / (exp(ability_hi) + exp(ability_lo))
    return(rbinom(1, 1, prob_hi_wins_tiebreak))  # weighted shootout
  }
}

possible_matchups
```

```{r}
#| code-fold: true
#| code-summary: Simulation of quarterfinals through final with combined domestic and UCL-fitted Bradley-Terry model
n_sims = 10000

alt_results = data.frame(
  QF_Match1 = rep(NA, n_sims),
  QF_Match2 = rep(NA, n_sims),
  QF_Match3 = rep(NA, n_sims),
  QF_Match4 = rep(NA, n_sims),
  QF_Winner1 = rep(NA, n_sims),
  QF_Winner2 = rep(NA, n_sims),
  QF_Winner3 = rep(NA, n_sims),
  QF_Winner4 = rep(NA, n_sims),
  SF_Match1 = rep(NA, n_sims),
  SF_Match2 = rep(NA, n_sims),
  SF1_Winner = rep(NA, n_sims),
  SF2_Winner = rep(NA, n_sims),
  Finals_Hi = rep(NA, n_sims),
  Finals_Lo = rep(NA, n_sims),
  Champion = rep(NA, n_sims)
)

for (r in 1:n_sims) {
  set.seed(321 + r)
  
  # qf
  qf_winners = rep(NA, nrow(possible_matchups))
  
  for (i in 1:nrow(possible_matchups)) {
    result = simulate_two_leg_goals(
      ability_hi = possible_matchups$Hi_ability[i],
      ability_lo = possible_matchups$Lo_ability[i],
      avg_goals = 3.205357
    )
    qf_winners[i] = ifelse(result == 1, possible_matchups$Hi[i], possible_matchups$Lo[i])
    
    # store QF matchups
    alt_results[r, paste0("QF_Match", i)] =
      paste(possible_matchups$Hi[i], "vs", possible_matchups$Lo[i])
    alt_results[r, paste0("QF_Winner", i)] = qf_winners[i]
  }
  
  # sf
  semis = data.frame(
    Hi = c(qf_winners[1], qf_winners[3]),
    Lo = c(qf_winners[2], qf_winners[4])
  ) %>%
    dplyr::left_join(combined_lambda_hat %>% dplyr::select(team, ability),
                     by = c("Hi" = "team")) %>%
    dplyr::rename(Hi_ability = ability) %>%
    dplyr::left_join(combined_lambda_hat %>% dplyr::select(team, ability),
                     by = c("Lo" = "team")) %>%
    dplyr::rename(Lo_ability = ability)
  
  sf_winners = rep(NA, nrow(semis))
  for (i in 1:nrow(semis)) {
    result = simulate_two_leg_goals(
      ability_hi = semis$Hi_ability[i],
      ability_lo = semis$Lo_ability[i],
      avg_goals = 3.205357
    )
    sf_winners[i] = ifelse(result == 1, semis$Hi[i], semis$Lo[i])
    
    # store SF matchups
    alt_results[r, paste0("SF_Match", i)] =
      paste(semis$Hi[i], "vs", semis$Lo[i])
  }
  
  alt_results[r, c("SF1_Winner", "SF2_Winner")] = sf_winners
  
  # finals
  finals = data.frame(
    Team1 = sf_winners[1],
    Team2 = sf_winners[2]
  ) %>%
    dplyr::left_join(
      combined_lambda_hat %>% dplyr::rename(Team1 = team, Team1_Ability = ability),
      by = "Team1"
    ) %>%
    dplyr::left_join(
      combined_lambda_hat %>% dplyr::rename(Team2 = team, Team2_Ability = ability),
      by = "Team2"
    ) %>%
    dplyr::mutate(
      Hi = ifelse(Team1_Ability > Team2_Ability, Team1, Team2),
      Lo = ifelse(Team1_Ability > Team2_Ability, Team2, Team1),
      Hi_ability = pmax(Team1_Ability, Team2_Ability),
      Lo_ability = pmin(Team1_Ability, Team2_Ability),
      prob = exp(Hi_ability) / (exp(Hi_ability) + exp(Lo_ability))
    ) %>%
    dplyr::select(Hi, Lo, prob)
  
  alt_results[r, "Finals_Hi"] = finals$Hi[1]
  alt_results[r, "Finals_Lo"] = finals$Lo[1]
  
  # simulate one-leg final
  final_outcome = rbinom(1, 1, finals$prob[1])
  alt_results[r, "Champion"] =
    ifelse(final_outcome == 1, finals$Hi[1], finals$Lo[1])
}

# results
champions = alt_results %>%
  dplyr::count(Champion, sort = TRUE) %>%
  dplyr::mutate(Prob = n / n_sims)

champions
```

After simulating 10,000 times, we see results that are in line with the Bradley-Terry latent strengths we derived earlier. Primarily, PSG (which had the strongest ability) won 48.6% of the simulation's runs, while Barcelona and Manchester City were the 2nd and 3rd most common winners. We see actual winners, Bayern Munich, in the 6th likeliest position to win, suggesting either our results are faulty, or real results deviated strongly from our expectation.

```{r}
#| echo: false
champions_plot = champions %>%
  ggplot(aes(x = reorder(Champion, Prob), y = Prob)) +
  geom_col(fill = "#1f78b4") +
  geom_text(aes(label = scales::percent(Prob, accuracy = 0.1)),
            hjust = -0.1, size = 4) +
  coord_flip(clip = "off") + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 1), limits = c(0, max(champions$Prob) * 1.15)) +
  labs(
    title = "Simulated Champions (10,000 Runs)",
    subtitle = "2019–20 UEFA Champions League (BT + Poisson Model)",
    x = "Team",
    y = "Probability of Winning"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold"),
    axis.title.y = element_text(vjust = 1),
    axis.text.y = element_text(face = "bold"),
    plot.margin = margin(10, 40, 10, 10)  
  )

champions_plot
```

This trend also appears in the predicted semifinal and final match-ups, with neither of the two likeliest semifinal match-ups being the correct prediction based on the actual tournament, nor the actual final appearing in the top 4 likeliest.

```{r}
#| echo: false
sf_matchups = alt_results %>%
  select(SF_Match1, SF_Match2) %>%
  pivot_longer(cols = everything(), values_to = "Matchup") %>%
  count(Matchup, sort = TRUE) %>%
  mutate(Prob = n / n_sims)

sf_plot = sf_matchups %>%
  ggplot(aes(x = reorder(Matchup, Prob), y = Prob)) +
  geom_col(fill = "#1f78b4") +
  geom_text(
    aes(label = scales::percent(Prob, accuracy = 0.1)),
    hjust = -0.1, size = 4
  ) +
  coord_flip(clip = "off") +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    limits = c(0, max(sf_matchups$Prob) * 1.15)
  ) +
  labs(
    title = "Most Common Semifinal Matchups (10,000 Runs)",
    subtitle = "2019–20 UEFA Champions League Simulation (Bradley–Terry + Poisson)",
    x = "Semifinal Matchup",
    y = "Probability"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold"),
    axis.title.y = element_text(vjust = 1),
    axis.text.y = element_text(face = "bold"),
    plot.margin = margin(10, 40, 10, 10)
  )
sf_plot
```

```{r}
#| code-fold: true
#| code-summary: Simulation to determine most likely winners of 2019-2020 UCL with Bradley-Terry strengths
final_matchups = alt_results %>%
  mutate(
    Final_Pair = paste(
      pmin(Finals_Hi, Finals_Lo),
      pmax(Finals_Hi, Finals_Lo),
      sep = " vs "
    )
  ) %>%
  count(Final_Pair, sort = TRUE) %>%
  mutate(Prob = n / n_sims)

final_plot = final_matchups %>%
  ggplot(aes(x = reorder(Final_Pair, Prob), y = Prob)) +
  geom_col(fill = "#e31a1c") +
  geom_text(
    aes(label = scales::percent(Prob, accuracy = 0.1)),
    hjust = -0.1, size = 4
  ) +
  coord_flip(clip = "off") +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    limits = c(0, max(final_matchups$Prob) * 1.15)
  ) +
  labs(
    title = "Most Common Final Matchups (10,000 Runs)",
    subtitle = "2019–20 UEFA Champions League Simulation (Bradley–Terry + Poisson)",
    x = "Final Matchup",
    y = "Probability"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold"),
    axis.title.y = element_text(vjust = 1),
    axis.text.y = element_text(face = "bold"),
    plot.margin = margin(10, 40, 10, 10)
  )
final_plot

```

```{css ref.label="styles", echo=FALSE}
```

```{r ref.label="font_styles", echo=FALSE}
```

```{r echo=FALSE}
champs = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types = FALSE)
domestic_strength = read_csv('../data/ratings/UEFA_Champions_League_Domestic_Strengths.csv', show_col_types = FALSE)
```

## Introducing Covariates

### Fitting Bradley-Terry with Domestic Strength Covariate

Now, we'll move on from the traditional Bradley-Terry fitting process to fitting our strengths with covariates.

To begin, we'll normalize our derived domestic strengths for each team so that our model can better fit coefficients to the data, and prepare a data frame such that our Bradley-Terry model can be fit using these domestic strengths. Ideally, we'll use these strengths to define the probability, $$
\mathbb{P}(\text{team i with domestic strength x beats team j with domestic strength y}) = \frac{1}{1+e^{-1\times(((\lambda_i+x\lambda_0))-(\lambda_j+y\lambda_0))}}
$$

```{r}
# Normalize strengths
domestic_strength$ability = (domestic_strength$ability-mean(domestic_strength$ability))/sqrt(var(domestic_strength$ability))
domestic_strength
```

```{r}
#| echo: false
no_ties = champs %>%
  select(-c('Competition_Name','Gender','Country', 'Season_End_Year', 'Wk', 'Date', 'Day','Time', 'Home_xG', 'Away_xG', 'Attendance', 'Referee', 'Notes','Venue', 'MatchURL')) %>%
  filter(HomeGoals != AwayGoals & Round == 'Group stage') %>%
  select(-c('Round')) %>%
  mutate(Home = str_replace(Home, ' [a-z]{2,3}$', ''),
         Away = str_replace(Away, '^[a-z]{2,3} ', ''),
         Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),
         Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))

unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))
results = no_ties %>% 
  left_join(domestic_strength%>% select(Home, ability), relationship='many-to-many', by='Home') %>%
  rename(home.domestic = ability) %>%
  left_join(domestic_strength %>% rename(Away = Home) %>% select(Away, ability), relationship='many-to-many', by='Away') %>% rename(away.domestic = ability) %>%
  rename(home.team = Home, away.team = Away) %>%
    group_by(home.team, away.team) %>%
    dplyr::summarise(
        home.win = sum(Home_Winner),
        away.win = sum(Opp_Winner),
        home.domestic = mean(home.domestic),
        away.domestic = mean(away.domestic), .groups = 'drop') |>
    dplyr::mutate(
        home.team = factor(home.team, levels = unik_teams),
        away.team = factor(away.team, levels = unik_teams))

tmp = data.frame(home.win = results$home.win, away.win = results$away.win)
tmp$home.team = data.frame(
  team = results$home.team,
  domestic.strength = scale(results$home.domestic, center = TRUE, scale = TRUE)[,1]
)
tmp$away.team = data.frame(
  team = results$away.team,
  domestic.strength = scale(results$away.domestic, center = TRUE, scale = TRUE)[,1]
)
```

With our strengths now together, we'll do an initial fit of the Bradley-Terry model, and use the coefficient of `domestic.strength` for $\lambda_0$.

```{r}
suppressWarnings({
  fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    formula = ~ team + domestic.strength,
    refcat = "Dinamo Zagreb",
    id = "team",
    separate.ability = TRUE,
    data = tmp)
})
coef(fit)
```

Above, we see a significant issue: team strengths with the value `NA`. This likely arises due to the "disconnected" nature of the group stage data, or the nature that teams do not play other teams outside of their group. Therefore, to determine a strength for each team, we'll take a sample of reference teams, fit the Bradley-Terry model to each, and take the mean of each team's strength.

```{r}
#| code-fold: true
#| code-summary: Helper to run multiple Bradley-Terry fits with random sample of reference teams
run_mult_fits = function(num_fits, with_replacement = FALSE, full=FALSE){
  set.seed(439)
  champs = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types=FALSE)
  no_ties = champs %>%
    select(-c('Competition_Name','Gender','Country', 'Season_End_Year', 'Wk', 'Date', 'Day','Time', 'Home_xG', 'Away_xG', 'Attendance', 'Referee', 'Notes','Venue', 'MatchURL')) %>%
    filter(HomeGoals != AwayGoals & Round == 'Group stage') %>%
    select(-c('Round')) %>%
    mutate(Home = str_replace(Home, ' [a-z]{2,3}$', ''),
           Away = str_replace(Away, '^[a-z]{2,3} ', ''),
           Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),
           Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))
  unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))
  suppressWarnings({
    fit <-
    BradleyTerry2::BTm(
      outcome = cbind(home.win, away.win),
      player1 = home.team, player2 = away.team,
      formula = ~ team + domestic.strength,
      refcat = 'Ajax',
      id = "team",
      separate.ability = TRUE,
      data = tmp)
  })
  coefs = transpose(data.table(unik_teams))
  colnames(coefs) = coef(fit) %>% names
  coefs[1,] = 0
  for(i in 2:num_fits){
    zero_row = transpose(data.table(rep(0,length(colnames(coefs)))))
    colnames(zero_row) = coef(fit) %>% names
    coefs = coefs %>% rbind(zero_row)
  }
  coefs$Ref = sample(unik_teams,size=num_fits,replace=with_replacement)
  
  c = transpose(data.frame(coef(fit)))
  colnames(c) = coef(fit) %>% names
  coefs = coefs %>% select(c(colnames(c), str_c(),'Ref')) %>% select(-c('domestic.strength'))
  ref_cat = str_c('team',coefs[1,] %>% pull(Ref))
  c[1,'Ref'] = coefs[1,] %>% pull(Ref)
  coefs[1,] = c[1,] %>% select(-c('domestic.strength'))
  coefs[1,ref_cat] = 0
  coefs = coefs %>% select(sort(colnames(coefs)))
  
  for(i in 2:num_fits){
    suppressWarnings({
      fit <-
      BradleyTerry2::BTm(
        outcome = cbind(home.win, away.win),
        player1 = home.team, player2 = away.team,
        formula = ~ team + domestic.strength,
        refcat = coefs[i,] %>% pull(Ref),
        id = "team",
        separate.ability = TRUE,
        data = tmp)
    })
    c = transpose(data.frame(coef(fit)))
    colnames(c) = coef(fit) %>% names
    ref_cat = str_c('team',coefs[i,] %>% pull(Ref))
    c[1,'Ref'] = coefs[i,] %>% pull(Ref)
    c = c %>% select(-c('domestic.strength'))
    c[1,ref_cat] = 0
    c = c %>% select(colnames(coefs))
    coefs[i,] = c[1,]
  }
  
  coefs[is.na(coefs)] = 0
  teams = coefs %>% select(-c('Ref')) %>% names
  adjusted_coefs = c()
  for(i in 1:length(teams)){
    team = as.numeric(coefs %>% pull(teams[i]))
    team = team[team != 0]
    adjusted_coef = sum(team)/length(team)
    adjusted_coefs[length(adjusted_coefs) + 1] = adjusted_coef
  }
  adjusted = tibble(team = teams %>% str_replace('team', ''), ability = adjusted_coefs)
  if(full){
    return(list(coefs, adjusted))
  }
  return(adjusted)
}
```

```{r}
#| echo: false
lambda0_hat = -5.26800595 # from initial fit
lambda_hat = run_mult_fits(100, with_replacement=TRUE)
sd_ability = sd(c(lambda_hat$ability, lambda0_hat))
mu_ability = mean(c(lambda_hat$ability, lambda0_hat))

## normalizing results
lambda0_hat = (-5.26800595-mu_ability)/sd_ability
lambda_hat$ability = (lambda_hat$ability-mu_ability)/sd_ability

uefa_playoff_teams= c(
  "Atalanta", "RB Leipzig", "Barcelona", "Manchester City",
  "Lyon", "Paris S-G", "Atlético Madrid", "Bayern Munich"
)
uefa_playoff_team_strengths = lambda_hat[lambda_hat$team %in% uefa_playoff_teams,] %>% column_to_rownames('team')
forecasts = uefa_playoff_team_strengths %>% arrange(desc(ability))

knockout_column <- function(maxWidth = 120, class = NULL, ...) {
  colDef(
    cell = format_pct,
    maxWidth = maxWidth,
    class = paste("cell number", class),
    style = function(value) {
      # Lighter color for <1%
      if (value < 0.01) {
        list(color = "#aaa")
      } else {
        list(color = "#111", background = knockout_pct_color(value))
      }
    },
    ...
  )
}

format_pct <- function(value) {
  round(value, 2)
}

make_color_pal <- function(colors, bias = 1) {
  get_color <- colorRamp(colors, bias = bias)
  function(x) rgb(get_color(x/max(forecasts$ability)), maxColorValue = 255)
}

knockout_pct_color <- make_color_pal(c("#ffffff", "#f2fbd2", "#c9ecb4", "#93d3ab", "#35b0ab"), bias = 2)

tbl <- reactable(
  forecasts,
  pagination = FALSE,
  defaultSorted = "ability",
  defaultSortOrder = "desc",
  defaultColDef = colDef(
    vAlign = "center",
    headerVAlign = "bottom",
    class = "cell",
    headerClass = "header"
  ),
  columns = list(
    round_winner = colDef(
      name = "Team",
      defaultSortOrder = "asc",
      minWidth = 250,
      maxWidth = 300,
      headerStyle = list(fontWeight = 700),
      class = "cell team-name",
      cell = function(value, index) {
        div(
          class = "team",
          img(class = "team-flag", alt = sprintf("images/%s.png", value), src = sprintf("images/%s.png", value)),
          div(
            span(class = "team-name", value)
          )
        )
        }
    ),
    ability = knockout_column(name = "Team Strength", maxWidth = 150)
  ),
  showSortIcon = FALSE,
  borderless = TRUE,
  class = "standings-table"
)

div(class = "standings",
  div(class = "title",
    h3("Normalized Team Strengths for Quarterfinal Participants"),
    h4("Latent team strengths found and normalized after fitting Bradley-Terry model with domestic strength covariate")
  ),
  tbl
)
```

With our team strengths in place, we can now begin computing the probabilities for each potential match-up that occurs in the quarterfinal through the final round, based on the formula described above.

```{r}
#| code-fold: true
#| code-summary: Computing pairwise probabilities for possible matchups with covariate for domestic strength
suppressMessages({
  possible_matchups =
    expand.grid(team1 = rownames(uefa_playoff_team_strengths), team2 = rownames(uefa_playoff_team_strengths)) %>%
    as.data.frame() %>%
    filter(team1 != team2) %>%
    dplyr::mutate(
      team1_strength = uefa_playoff_team_strengths[team1, "ability"], team2_strength = uefa_playoff_team_strengths[team2, "ability"])
  
  possible_matchups = possible_matchups %>%
    left_join(domestic_strength %>%
                rename(team1 = Home)) %>%
    select(-c('Country','s.e.')) %>%
    rename(team1_domestic = ability)
  possible_matchups = possible_matchups %>%
    left_join(domestic_strength %>%
                rename(team2 = Home)) %>%
    select(-c('Country','s.e.')) %>%
    rename(team2_domestic = ability)
  
  possible_matchups = possible_matchups %>% mutate(
    prob = 1/(1+exp(-1*((team1_strength+(team1_domestic*lambda0_hat))-(team2_strength+(team2_domestic*lambda0_hat)))))
  )
})
possible_matchups %>% select(c('team1','team2','prob')) %>% head(10)
```

```{r}
#| echo: false
#| include: false
group_stage = champs %>% filter(Round == 'Group stage') %>% select(-c('Competition_Name','Gender','Country', 'Season_End_Year', 'Wk', 'Date', 'Day','Time', 'Home_xG', 'Away_xG', 'Attendance', 'Referee', 'Notes','Venue', 'MatchURL')) %>%
    select(-c('Round')) %>%
    mutate(Home = str_replace(Home, ' [a-z]{2,3}$', ''),
           Away = str_replace(Away, '^[a-z]{2,3} ', ''))
group_stage
```

Since each round but the final takes place over two games, the chance of seeing the teams split the two games is high. Therefore, we need a way to choose a winner based on some other source of information. Thankfully, we have access to goal scoring data from the group stage, which we can use to make an informed estimation of the tie-breaking criteria that is used in this case in the actual UCL tournament: goal aggregate. For this, we'll take the mean of the goals scored for each team throughout the group stage and use it as the parameter for a Poisson distribution. Poisson distributions have long been used for simulating goals scored for a particular team, often utilizing the same methodology to choose the value of $\lambda$ [@poisson].

In other words, in the event of a tie between the two legs, we'll choose a goal value based on the following distribution:\
$$\lambda_i = \text{mean goals for team i in group stage}; \text{Draw from Pois}(\lambda_i)=\text{team i goals}$$

The helper function below will run a single iteration of our simulation:

```{r run single iteration with domestic strength covariate}
#| code-fold: true
#| code-summary: Helper function to run a single iteration of UCL tournament from quarterfinal to final with Bradley-Terry model fitted with domestic strength covariate
run_iteration = function(seed=439, verbose=FALSE){
  knockout = tibble(round = c(rep('Quarter', 4), c(rep('Semi', 2)), 'Final'), team1 = rep('',7), team2 = rep('',7), winner = rep('',7))
  knockout[1,'team1'] = 'RB Leipzig'
  knockout[1,'team2'] = 'Atlético Madrid'
  
  knockout[2,'team1'] = 'Atalanta'
  knockout[2,'team2'] = 'Paris S-G'
  
  knockout[3,'team1'] = 'Manchester City'
  knockout[3,'team2'] = 'Lyon'
  
  knockout[4,'team1'] = 'Barcelona'
  knockout[4,'team2'] = 'Bayern Munich'
  set.seed(seed)
  quarters = c()
  for(i in 1:4){
    team_a = knockout[i,] %>% pull('team1')
    team_b = knockout[i,] %>% pull('team2')
    prob_team1 = possible_matchups %>% filter(team1 == team_a & team2 == team_b) %>% pull('prob')
    if(verbose){
      print(str_c("Quarter ",i," Probability that team 1 ", team_a, " beats team 2 ", team_b, " :", prob_team1))
    }
    results = rbinom(n=2, size=1, prob=prob_team1)
    if(results[1] != results[2]){
      if(verbose){
        print(str_c(team_a, " and ", team_b, " split series. Using tie breaker..."))
      }
      mean_team1 = group_stage %>% filter(Home == team_a | Away == team_a) %>%
        mutate(TotGoals = case_when(Home == team_a ~ HomeGoals, Away == team_a ~ AwayGoals)) %>%
        select(TotGoals) %>% pull(TotGoals) %>% as.numeric() %>%
        mean()
      
      mean_team2 = group_stage %>% filter(Home == team_b | Away == team_b) %>%
        mutate(TotGoals = case_when(Home == team_b ~ HomeGoals, Away == team_b ~ AwayGoals)) %>%
        select(TotGoals) %>% pull(TotGoals) %>%
        as.numeric() %>%
        mean()
      
      ## choose winner
      team1_goals = rpois(1, mean_team1)
      team2_goals = rpois(1, mean_team2)
      while(team1_goals == team2_goals){
        team1_goals = rpois(1, mean_team1)
        team2_goals = rpois(1, mean_team2)
      }
      if(verbose){
        print(str_c(team_a, " scored ", team1_goals))
        print(str_c(team_b, " scored ", team2_goals))
      }
      if(team1_goals > team2_goals){
        winner = team_a
      }
      else {
        winner = team_b
      }
    }
    else if(sum(as.numeric(results)) == 2){
      winner = team_a
    }
    else{
      winner = team_b
    }
    quarters[length(quarters)+1] = winner
  }
  knockout[c(1:4),'winner']= quarters
  knockout[5,c('team1', 'team2')] = as.list(quarters[c(1,2)])
  knockout[6,c('team1', 'team2')] = as.list(quarters[c(3,4)])
  semis = c()
  for(i in 5:6){
    team_a = knockout[i,] %>% pull('team1')
    team_b = knockout[i,] %>% pull('team2')
    prob_team1 = possible_matchups %>% filter(team1 == team_a & team2 == team_b) %>% pull('prob')
    if(verbose){
      print(str_c("Semi ",i-4," Probability that team 1 ", team_a, " beats team 2 ", team_b, " :", prob_team1))
    }
    results = rbinom(n=2, size=1, prob=prob_team1)
    if(results[1] != results[2]){
      if(verbose){
        print(str_c(team_a, " and ", team_b, " split series. Using tie breaker..."))
      }
      mean_team1 = group_stage %>% filter(Home == team_a | Away == team_a) %>%
        mutate(TotGoals = case_when(Home == team_a ~ HomeGoals, Away == team_a ~ AwayGoals)) %>%
        select(TotGoals) %>% pull(TotGoals) %>% as.numeric() %>%
        mean()
      mean_team2 = group_stage %>% filter(Home == team_b | Away == team_b) %>%
        mutate(TotGoals = case_when(Home == team_b ~ HomeGoals, Away == team_b ~ AwayGoals)) %>%
        select(TotGoals) %>% pull(TotGoals) %>%
        as.numeric() %>%
        mean()
      ## choose winner
      team1_goals = rpois(1, mean_team1)
      team2_goals = rpois(1, mean_team2)
      while(team1_goals == team2_goals){
        team1_goals = rpois(1, mean_team1)
        team2_goals = rpois(1, mean_team2)
      }
      
      if(verbose){
        print(str_c(team_a, " scored ", team1_goals))
        print(str_c(team_b, " scored ", team2_goals))
      }
      if(team1_goals > team2_goals){
        winner = team_a
      }
      else {
        winner = team_b
      }
    }
    else if(sum(as.numeric(results)) == 2){
      winner = team_a
    }
    else{
      winner = team_b
    }
    semis[length(semis)+1] = winner
  }
  knockout[c(5:6),'winner']= semis
  knockout[7,c('team1', 'team2')] = as.list(semis[c(1,2)])
  i = 7
  team_a = knockout[i,] %>% pull('team1')
  team_b = knockout[i,] %>% pull('team2')
  prob_team1 = possible_matchups %>% filter(team1 == team_a & team_b == team2) %>% pull('prob')
  if(verbose){
    print(str_c("Final: Probability that team 1 ", team_a, " beats team 2 ", team_b, " :", prob_team1))
  }
  result = rbinom(n=1, size=1, prob=prob_team1)
  if(result == 1){
    winner = team_a
  } else {
    winner = team_b
  }
  if(verbose){
    print(str_c(winner, " WINS"))
  }
  knockout[7,'winner'] = winner
  return(knockout)
}
```

We'll run one simulation to get an idea of how the results are structured and use the `verbose` option to get a read of the simulation's stages.

```{r}
#| echo: true
# Example of simulation when run verbose
run_iteration(verbose=TRUE)
```

```{r}
#| echo: false
# Helper to run n iterations, starting small
run_n_iterations = function(n, seed=439, show_output=FALSE){
  n_iters = n
  sims = run_iteration()
  for(i in 2:n_iters){
    sims = sims %>% rbind(run_iteration(seed=seed*i, verbose=show_output))
  }
  return(sims)
}
sims = run_n_iterations(10)
sims %>% filter(round == 'Final') %>% group_by(winner) %>% count()
```

```{r}
# Medium-sized number of iterations
sims = run_n_iterations(1000, seed=12)
sims %>% filter(round == 'Final') %>% group_by(winner) %>% count()
```

After getting an idea of what type of results we should see, let's run the simulation 10,000 times to get an idea of how we would expect the tournament to play out given our conditions.

```{r}
#| eval: false
sims = run_n_iterations(10000)
```

```{r}
#| echo: false
sims = read_csv('../data/simulations/SimulationResultsWithDomesticCovariate.csv', show_col_types = FALSE)
win_summary = sims %>% filter(round == 'Final') %>% group_by(winner) %>% count() %>% arrange(desc(n))
win_summary %>% mutate(prob = n/sum(win_summary$n))
```

```{r}
#| echo: false
final_summary = sims %>% filter(round == 'Final') %>% group_by(team1, team2) %>% count() %>% arrange(desc(n))
final_summary %>% mutate(prob = n/sum(final_summary$n))
```

From the two tables above, we see both results that align with the real outcome of the tournament (PSG vs. Bayern) along with results that diverge from history (PSG winning the tournament). Overall, although the predicted winner, PSG, didn't win in real life, our results do roughly align with the match-ups and outcomes seen throughout the actual tournament. For instance, let's view the most common semifinal match-ups:

```{r}
#| echo: false
semi_summary = sims %>% filter(round == 'Semi') %>%
  group_by(team1, team2) %>% 
  count() %>%
  arrange(desc(n))
semi_summary %>% mutate(prob = n/sum(semi_summary$n))
```

The top two results, Manchester City vs. Bayern Munich and RB Leipzig vs. PSG were the two actual semifinal match-ups in the 2019-2020 tournament.

## Integrating Home Field Advantage

We can refine the model above by also taking into account the advantage derived from playing at home throughout the group stage. From this, we'll define the probability that team *i* beats team *j*, given team i and team j's domestic strengths, and if team i is playing at home. This probability can be expressed as, $$
\mathbb{P}(\text{team i with domestic strength x beats team j with domestic strength y at i's home}) = \\ \frac{1}{1+e^{-1\times(((\lambda_i+x\lambda_0)+\lambda_1)-(\lambda_j+y\lambda_0))}}
$$

Thus, we'll restructure our results data frame to work with the `BradleyTerry2` package with the domestic strengths we previously used and an indicator *at.home* for whether team i was at home or not.

```{r}
#| echo: true
unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))
results = no_ties %>% 
  left_join(domestic_strength%>% select(Home, ability), relationship='many-to-many', by='Home') %>%
  rename(home.domestic = ability) %>%
  left_join(domestic_strength %>% rename(Away = Home) %>% select(Away, ability), relationship='many-to-many', by='Away') %>% rename(away.domestic = ability) %>%
  rename(home.team = Home, away.team = Away) %>%
    group_by(home.team, away.team) %>%
    dplyr::summarise(
        home.win = sum(Home_Winner),
        away.win = sum(Opp_Winner),
        home.domestic = mean(home.domestic),
        away.domestic = mean(away.domestic), .groups = 'drop') |>
    dplyr::mutate(
        home.team = factor(home.team, levels = unik_teams),
        away.team = factor(away.team, levels = unik_teams),
        home.athome = 1,
        away.athome = 0)

tmp = data.frame(home.win = results$home.win, away.win = results$away.win)
tmp$home.team = data.frame(
  team = results$home.team,
  domestic.strength = scale(results$home.domestic, center = TRUE, scale = TRUE)[,1],
  at.home = results$home.athome
)
tmp$away.team = data.frame(
  team = results$away.team,
  domestic.strength = scale(results$away.domestic, center = TRUE, scale = TRUE)[,1],
  at.home = results$away.athome
)
```

```{r}
#| echo: true
suppressWarnings({
  fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    formula = ~ team + domestic.strength + at.home,
    refcat = "Dinamo Zagreb",
    id = "team",
    separate.ability = TRUE,
    data = tmp)
})
coef(fit)
```

From the above, we see that the raw coefficient given to home pitch advantage is approximately 0.065. However, to remain consistent with the normalization standards we've used throughout this section, we'll normalize this value given the mean and standard deviation of the previous coefficients.

```{r}
lambda1_hat = (0.06547312-mu_ability)/sd_ability
lambda1_hat
```

After this normalization, our home advantage coefficient is negative, suggesting there is a disadvantage to playing at home. While this isn't intuitive, given a history of literature in this area suggesting otherwise, it is possible that given this small sample, there was enough information to suggest this disadvantage. With that said, this is most likely due to the fact that we are normalizing this coefficient, which isn't necessarily standard in this form of model fitting. Later, we'll manually input a $\lambda$ for home advantage to determine if there is enough variation to indicate these results being faulty.

```{r}
#| include: false
possible_matchups_w_home =
  expand.grid(team1 = rownames(uefa_playoff_team_strengths), team2 = rownames(uefa_playoff_team_strengths)) %>%
  as.data.frame() %>%
  filter(team1 != team2) %>%
  dplyr::mutate(
    team1_strength = uefa_playoff_team_strengths[team1, "ability"], team2_strength = uefa_playoff_team_strengths[team2, "ability"])

possible_matchups_w_home = possible_matchups_w_home %>%
  left_join(domestic_strength %>%
              rename(team1 = Home)) %>%
  select(-c('Country','s.e.')) %>%
  rename(team1_domestic = ability)
possible_matchups_w_home = possible_matchups_w_home %>%
  left_join(domestic_strength %>%
              rename(team2 = Home)) %>%
  select(-c('Country','s.e.')) %>%
  rename(team2_domestic = ability)

possible_matchups_w_home = possible_matchups_w_home %>%
  rename(home = team1, away = team2) %>% 
  mutate(
    prob = 1/(1+exp(-1*((team1_strength+(team1_domestic*lambda0_hat)+lambda1_hat)-(team2_strength+(team2_domestic*lambda0_hat)))))
  )
possible_matchups_w_home
```

Because we are now factoring in home vs. away in this version of our simulation, we have to track who's home during which leg. Throughout an actual tournament, in a two-leg round, each team plays one match at home. Thus, we've implemented this below, along with using the probability involving the normalized *at.home* coefficient.

```{r}
#| code-fold: true
#| code-summary: Helper to run single iteration of UCL tournament from quarterfinals through final with covariates for domestic strength and home field advantage
run_iteration_w_home = function(seed=439, proba = possible_matchups_w_home){
  set.seed(seed)
  knockout = tibble(round = c(rep('Quarter', 8),c(rep('Semi', 4)), 'Final'), 
                    matchup_id = c(rep(1,2),rep(2,2),rep(3,2),rep(4,2),rep(5,2),rep(6,2),7), 
                    leg = c(rep(c(1,2),6), 1),home = rep('',13), away = rep('',13), 
                    leg_winner = rep('',13), 
                    round_winner = rep('', 13))
  knockout[1,'home'] = 'RB Leipzig'
  knockout[1,'away'] = 'Atlético Madrid'
  knockout[2,'home'] = 'Atlético Madrid'
  knockout[2,'away'] = 'RB Leipzig'
  
  knockout[3,'home'] = 'Atalanta'
  knockout[3,'away'] = 'Paris S-G'
  knockout[4,'home'] = 'Paris S-G'
  knockout[4,'away'] = 'Atalanta'
  
  knockout[5,'home'] = 'Manchester City'
  knockout[5,'away'] = 'Lyon'
  knockout[6,'home'] = 'Lyon'
  knockout[6,'away'] = 'Manchester City'
  
  knockout[7,'home'] = 'Barcelona'
  knockout[7,'away'] = 'Bayern Munich'
  knockout[8,'home'] = 'Bayern Munich'
  knockout[8,'away'] = 'Barcelona'
  quarters = c()
  for(offset in 1:4){
    for(i in 1:2){
    index = i+((offset-1)*2)
    team_a = knockout[index,] %>% pull('home')
    team_b = knockout[index,] %>% pull('away')
    prob_team1 = proba %>% filter(home == team_a & away == team_b) %>% pull('prob')
    results = rbinom(n=1, size=1, prob=prob_team1)
    if(sum(as.numeric(results)) == 1){
      winner = team_a
    }
    else{
      winner = team_b
    }
    knockout[index, 'leg_winner'] = winner
    if(i == 2){
      if(winner == knockout[index-1,]%>%pull('leg_winner')){
        knockout[index, 'round_winner'] = winner
        quarters[length(quarters)+1] = winner
      }
      else {
        mean_team1 = group_stage %>% filter(Home == team_a | Away == team_a) %>%
          mutate(TotGoals = case_when(Home == team_a ~ HomeGoals, Away == team_a ~ AwayGoals)) %>%
          select(TotGoals) %>% pull(TotGoals) %>% as.numeric() %>%
          mean()
        mean_team2 = group_stage %>% filter(Home == team_b | Away == team_b) %>%
          mutate(TotGoals = case_when(Home == team_b ~ HomeGoals, Away == team_b ~ AwayGoals)) %>%
          select(TotGoals) %>% pull(TotGoals) %>%
          as.numeric() %>%
          mean()
        ## choose winner
        team1_goals = rpois(1, mean_team1)
        team2_goals = rpois(1, mean_team2)
        while(team1_goals == team2_goals){
          team1_goals = rpois(1, mean_team1)
          team2_goals = rpois(1, mean_team2)
        }
        
        if(team1_goals > team2_goals){
          knockout[index, 'round_winner'] = team_a
          quarters[length(quarters)+1] = team_a
        }
        else {
          knockout[index, 'round_winner'] = team_b
          quarters[length(quarters)+1] = team_b
        }
      }
    }
  }
  }
  knockout[9,c('home', 'away')] = as.list(quarters[c(1,2)])
  knockout[10,c('home', 'away')] = as.list(rev(quarters[c(1,2)]))
  knockout[11,c('home', 'away')] = as.list(quarters[c(3,4)])
  knockout[12,c('home', 'away')] = as.list(rev(quarters[c(3,4)]))
  semis = c()
  for(offset in 5:6){
    for(i in 1:2){
      index = i+((offset-1)*2)
      team_a = knockout[index,] %>% pull('home')
      team_b = knockout[index,] %>% pull('away')
      prob_team1 = proba %>% filter(home == team_a & away == team_b) %>% pull('prob')
      results = rbinom(n=1, size=1, prob=prob_team1)
      if(sum(as.numeric(results)) == 1){
        winner = team_a
      }
      else{
        winner = team_b
      }
      knockout[index, 'leg_winner'] = winner
      if(i == 2){
        if(winner == knockout[index-1,]%>%pull('leg_winner')){
          knockout[index, 'round_winner'] = winner
          semis[length(semis)+1] = winner
        }
        else {
          mean_team1 = group_stage %>% filter(Home == team_a | Away == team_a) %>%
            mutate(TotGoals = case_when(Home == team_a ~ HomeGoals, Away == team_a ~ AwayGoals)) %>%
            select(TotGoals) %>% pull(TotGoals) %>% as.numeric() %>%
            mean()
          mean_team2 = group_stage %>% filter(Home == team_b | Away == team_b) %>%
            mutate(TotGoals = case_when(Home == team_b ~ HomeGoals, Away == team_b ~ AwayGoals)) %>%
            select(TotGoals) %>% pull(TotGoals) %>%
            as.numeric() %>%
            mean()
          ## choose winner
          team1_goals = rpois(1, mean_team1)
          team2_goals = rpois(1, mean_team2)
          while(team1_goals == team2_goals){
            team1_goals = rpois(1, mean_team1)
            team2_goals = rpois(1, mean_team2)
          }
          
          if(team1_goals > team2_goals){
            knockout[index, 'round_winner'] = team_a
            semis[length(semis)+1] = team_a
          }
          else {
            knockout[index, 'round_winner'] = team_b
            semis[length(semis)+1] = team_b
          }
        }
      }
    }
  }
  knockout[13,c('home', 'away')] = as.list(semis[c(1,2)])
  team_a = knockout[13,] %>% pull('home')
  team_b = knockout[13,] %>% pull('away')
  prob_team1 = possible_matchups %>% filter(team1 == team_a & team_b == team2) %>% pull('prob')
  
  result = rbinom(n=1, size=1, prob=prob_team1)
  if(result == 1){
    winner = team_a
  } else {
    winner = team_b
  }
  knockout[13,'leg_winner'] = winner
  knockout[13,'round_winner'] = winner
  return(knockout)
}
```

Again, let's start small, and get an idea of how our data will turn out.

```{r}
#| echo: true
run_n_iterations_w_home = function(n, seed=439){
  n_iters = n
  sims = run_iteration_w_home(seed)
  for(i in 2:n_iters){
    sims = sims %>% rbind(run_iteration_w_home(seed=seed*i))
  }
  return(sims)
}
sims = run_n_iterations_w_home(10)
sims %>% filter(round == 'Final') %>% group_by(round_winner) %>% count()
```

As mentioned earlier, we want to be able to modify the $\lambda_1$ value manually. So, we'll modify the helper to allow us to pass an argument to control this value.

```{r}
run_n_iterations_w_home = function(n, lambda, seed=439){
  matchups =
  expand.grid(team1 = rownames(uefa_playoff_team_strengths), team2 = rownames(uefa_playoff_team_strengths)) %>%
  as.data.frame() %>%
  filter(team1 != team2) %>%
  dplyr::mutate(
    team1_strength = uefa_playoff_team_strengths[team1, "ability"], team2_strength = uefa_playoff_team_strengths[team2, "ability"])

  matchups = matchups %>%
    left_join(domestic_strength %>%
                rename(team1 = Home), by='team1') %>%
    select(-c('Country','s.e.')) %>%
    rename(team1_domestic = ability)
  matchups = matchups %>%
    left_join(domestic_strength %>%
                rename(team2 = Home),  by='team2') %>%
    select(-c('Country','s.e.')) %>%
    rename(team2_domestic = ability)
  
  matchups = matchups %>%
    rename(home = team1, away = team2) %>% 
    mutate(
      prob = 1/(1+exp(-1*((team1_strength+(team1_domestic*lambda0_hat)+lambda)-(team2_strength+(team2_domestic*lambda0_hat)))))
    )
  n_iters = n
  sims = run_iteration_w_home(seed)
  for(i in 2:n_iters){
    sims = sims %>% rbind(run_iteration_w_home(seed=seed*i, proba=matchups))
  }
  return(sims)
}
```

Let's compare the results of simulating the knockout stages past the round of 16 with both $\lambda_1*$, the normalized lambda for home pitch advantage, as well as the original computation for $\lambda_1=0.065$.

*Results of using* $\lambda_1=-0.0245$

```{r}
sims = run_n_iterations_w_home(1000, lambda1_hat)
sims %>% filter(round == 'Final') %>% group_by(round_winner) %>% count() %>% arrange(desc(n))
```

*Results of using* $\lambda_1=0.0654$

```{r}
sims = run_n_iterations_w_home(1000, 0.06547312 )
sims %>% filter(round == 'Final') %>% group_by(round_winner) %>% count() %>% arrange(desc(n))
```

A surface-level analysis of the two results suggests that the normalized coefficient doesn't make much of an impact on the results of the model, with teams like PSG only seeing a change of 4.5% (413 vs. 435). Overall, the results do not significantly deviate from the standings computed when just using the domestic strength covariate, with Bayern, Manchester City, and PSG still leading the way.

*Summary of tournament winners with 10,000 simulations and* $\lambda_1=0.06547312$

```{r}
#| echo: false
#sims = run_n_iterations_w_home(10000, 0.06547312)
sims = read_csv('../data/simulations/SimulationResultsWithDomesticAndHome.csv', show_col_types=FALSE)
winner_w_home_summary = sims %>% filter(round == 'Final') %>% group_by(round_winner) %>% count()
winner_w_home_summary = winner_w_home_summary %>% mutate(prob = n/sum(winner_w_home_summary$n)) %>% arrange(desc(n))
winner_w_home_summary
```

*Summary of final round match-ups with 10,000 simulations and* $\lambda_1=0.06547312$

```{r}
#| echo: false
final_w_home_summary = sims %>% filter(round == 'Final') %>%
  group_by(home,away) %>% count() %>%
  mutate(prob = n/sum(winner_w_home_summary$n)) %>%
  arrange(desc(n))
final_w_home_summary
```

### Aside: $\lambda_1$ (Home Field Advantage) Impact

For a quick analysis into the impact of this $\lambda_1$ value, let's compare the percentage that Bayern wins the tournament at varying values of $\lambda_1$. We'll utilize `0.065`, `0.2`, and `0.5` as a baseline value, medium-strength value, and strong home field advantage value respectively.

```{r}
#| echo: false
#| include: false
lambda_summary = tibble(home_advantage = c(0.065, 0.2, 0.5), prob_win = c(0,0,0))
for(i in 1:nrow(lambda_summary)){
  sim = run_n_iterations_w_home(1000, lambda_summary[i,]%>%pull(home_advantage) )
  s = sim %>% filter(round == 'Final') %>%
    group_by(round_winner) %>% count()
  
  prob_win_b = s %>% mutate(prob = n/sum(s$n)) %>% arrange(desc(n)) %>%
    filter(round_winner == 'Bayern Munich') %>% pull(prob)
  lambda_summary[i,'prob_win'] = prob_win_b
}
```

```{r}
#| echo: false
plot = ggplot(lambda_summary, aes(x=as.character(home_advantage), y=round(prob_win-0.3125, 3)*100, fill=as.character(home_advantage))) + geom_col() + scale_fill_manual(values = c("#99f2dd", "#4e60ba", "#0047ba")) + labs(title = '% Change in Probability of Bayern Munich Win By Home Advantage λ', x = 'λ', y = 'Probability of Bayern Munich Win') + guides(fill = guide_legend(title = 'Home Advantage λ'))
plot
```

The above graph shows that even with a substantial home field advantage, `0.5`, the observed effect is only a 1% increase in their win rate across 1,000 competitions.

## Summary

As seen throughout this final section, our results suggest that the real outcome of the 2019-2020 UEFA Champions League knockouts somewhat follow the expectation of our models. Whether with domestic strengths, or domestic strengths and home pitch advantage, we saw that the likeliest final was Bayern Munich-Paris S-G, which aligned with the real outcome, with PSG winning the bulk of the simulations, which didn't. Surprisingly, this was true in our previous model, even though that saw some erroneous results inside of the top 5, which suggests that PSG should've been the favorite in this competition and may have been impacted by the changed format.

With that said, this model did perform better from a qualitiative and quantitative standpoint than our earlier models, suggesting that fitting only on group stage data, normalizing, and introducing the covariates did positively benefit the performance of the simulation.

```{r}
#| echo: false
forecasts <- read_csv('../data/simulations/SimulationResultsWithDomesticAndHome.csv', show_col_types = FALSE)
forecasts = forecasts %>% filter(round == 'Final') %>% group_by(round_winner) %>% count()
forecasts = forecasts %>% mutate(prob = n/sum(forecasts$n)) %>% arrange(desc(n)) %>% select(-c(n))

knockout_column <- function(maxWidth = 120, class = NULL, ...) {
  colDef(
    cell = format_pct,
    maxWidth = maxWidth,
    class = paste("cell number", class),
    style = function(value) {
      # Lighter color for <1%
      if (value < 0.01) {
        list(color = "#aaa")
      } else {
        list(color = "#111", background = knockout_pct_color(value))
      }
    },
    ...
  )
}

format_pct <- function(value) {
  if (value == 0) "  \u2013 "    # en dash for 0%
  else if (value == 1) "\u2713"  # checkmark for 100%
  else if (value < 0.01) " <1%"
  else if (value > 0.99) ">99%"
  else formatC(paste0(round(value * 100), "%"), width = 4)
}

make_color_pal <- function(colors, bias = 1) {
  get_color <- colorRamp(colors, bias = bias)
  function(x) rgb(get_color(x), maxColorValue = 255)
}

knockout_pct_color <- make_color_pal(c("#ffffff", "#f2fbd2", "#c9ecb4", "#93d3ab", "#35b0ab"), bias = 2)

tbl <- reactable(
  forecasts,
  pagination = FALSE,
  defaultSorted = "prob",
  defaultSortOrder = "desc",
  defaultColDef = colDef(
    vAlign = "center",
    headerVAlign = "bottom",
    class = "cell",
    headerClass = "header"
  ),
  columns = list(
    round_winner = colDef(
      name = "Team",
      defaultSortOrder = "asc",
      minWidth = 250,
      maxWidth = 300,
      headerStyle = list(fontWeight = 700),
      class = "cell team-name",
      cell = function(value, index) {
        div(
          class = "team",
          img(class = "team-flag", alt = sprintf("images/%s.png", value), src = sprintf("images/%s.png", value)),
          div(
            span(class = "team-name", value)
          )
        )
        }
    ),
    prob = knockout_column(name = "Win Tournament", maxWidth = 150)
  ),
  showSortIcon = FALSE,
  borderless = TRUE,
  class = "standings-table"
)

div(class = "standings",
  div(class = "title",
    h2("2019-2020 UEFA Champions League Simulation"),
    h3("Chances of each team winning tournament based on 10,000 simulations with two-legs in knockout rounds.")
  ),
  tbl
)
```

```{r}
#| echo: false
final_matchups = sims %>% filter(round == 'Final') %>% group_by(home, away) %>% count() %>% arrange(desc(n)) %>% rename(team1 = home, team2 = away)
final_matchups$prob = final_matchups$n/sum(final_matchups$n)
forecasts = final_matchups %>% select(-c('n'))
tbl <- reactable(
  forecasts,
  pagination = FALSE,
  defaultSorted = "prob",
  defaultSortOrder = "desc",
  defaultColDef = colDef(
    vAlign = "center",
    headerVAlign = "bottom",
    class = "cell",
    headerClass = "header"
  ),
  columns = list(
    team1 = colDef(
      name = "Team 1",
      defaultSortOrder = "asc",
      maxWidth = 250,
      headerStyle = list(fontWeight = 700),
      class = "cell team-name",
      cell = function(value, index) {
        div(
          class = "team",
          img(class = "team-flag", alt = sprintf("images/%s.png", value), src = sprintf("images/%s.png", value)),
          div(
            span(class = "team-name", value)
          )
        )
        }
    ),
    team2 = colDef(
      name = "Team 2",
      defaultSortOrder = "asc",
      maxWidth = 250,
      headerStyle = list(fontWeight = 700),
      class = "cell team-name",
      cell = function(value, index) {
        div(
          class = "team",
          img(class = "team-flag", alt = sprintf("images/%s.png", value), src = sprintf("images/%s.png", value)),
          div(
            span(class = "team-name", value)
          )
        )
        }
    ),
    prob = knockout_column(name = "Made Final", maxWidth = 120)
  ),
  showSortIcon = FALSE,
  borderless = TRUE,
  class = "standings-table"
)

div(class = "standings",
  div(class = "title",
    h3("Chances of each team making tournament final based on 10,000 simulations with two-legs in knockout rounds."),
  ),
  tbl
)
```

### Challenges & Future Considerations

Throughout this project, we encountered several challenges that could see some improvement in the future. Namely, with fitting the Bradley-Terry models to the group stage, we saw significant deviations in team strengths, as well as missing values in model fitting due to the lack of team overlap in match-up results and a small sample size. Thus, our decisions to normalize the coefficients, as well as run several iterations of fitting to account for missing values may have skewed the team strengths somewhat. With that said, because our results aligned with those that played out in real life, there seems to be at least some merit to the process, including the use of domestic strengths as a covariate.

For future analyses of tournaments such as the UEFA Champions League, or other international competitions, it may be worthwhile to utilize simulations of not only the knockout stages, but also the group stages to observe a larger sample where deviations in results may be more evident. Further, a more detailed approach to breaking ties among aggregates could further differentiate our models from others, rather than utilizing the simplistic average goals-based Poisson model above.

```{r font_styles}
#| include: false
htmltools::tags$link(
  href = "https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap",
  rel = "stylesheet"
)
```

```{css styles, include=FALSE}
.standings {
  font-family: "JetBrains Mono", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 1em;
}

.team {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 0.75rem;
}

.team-flag {
  height: 2.5rem;
  margin-right: 0.25rem;
}

.title h3 {
  font-weight: 400;
}
```
