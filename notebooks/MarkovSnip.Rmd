---
title: "Pre-processing & Deriving Conditional League Strengths"
output: html_notebook
editor_options: 
  chunk_output_type: inline
references:
- id: lecture12
  author:
  - family: Deshpande
    given: Sameer
  publisher: "University of Wisconsin-Madison"
  title: "Lecture 12: Bradley-Terry Models"
  type: lecture
  issued:
    year: 2025
  url: "https://skdeshpande91.github.io/stat479_fall2025/lectures/lecture12.html"
---

```{r echo=FALSE}
require(devtools, quietly = TRUE)
require(tidyverse, quietly = TRUE)
# devtools::install_github("hturner/BradleyTerry2")
require(BradleyTerry2, quietly = TRUE)
library(scales)
require(gt)
#devtools::install_github("hrbrmstr/hrbrthemes", quiet = TRUE)
#require(hrbrthemes, quietly = TRUE)
```

## Data Overview

The following data was gathered using the `worldfootballR` library to scrape 2019-20 UEFA Champions League group stage and knockout game results and the 2018-19 domestic league results for the 32 competing teams across 16 individual league competitions[^1] from [fbref.com](https://www.fbref.com).

[^1]: Members from the following domestic leagues took part in the 2019-20 UEFA Champions League group stage: *Austrian Football Bundesliga, Belgian Pro League, Croatian Football League, Czech First League, English Premier League, French Ligue 1, German Fusball Bundesliga, Greek Super League, Italian Serie A, Dutch Eredivise, Portugese Premeira Liga, Russian Premier League, Serbian SuperLiga, Spanish La Liga, Turkish Super Lig, Ukrainian Premier League*

```{r echo=FALSE}
## Read in all league results
austria = readr::read_csv('../data/raw/Austria_Austrian_Football_Bundesliga_2018-19.csv', show_col_types = FALSE)
belgium = readr::read_csv('../data/raw/Belgium_Belgian_Pro_League_2018-19.csv', show_col_types = FALSE)
croatia = readr::read_csv('../data/raw/Croatia_Croatian_Football_League_2018-19.csv', show_col_types = FALSE)
czech = readr::read_csv('../data/raw/Czechia_Czech_First_League_2018-19.csv', show_col_types = FALSE)
england = readr::read_csv('../data/raw/England_Premier_League_2018-19.csv', show_col_types = FALSE)
france = readr::read_csv('../data/raw/France_Ligue_1_2018-19.csv', show_col_types = FALSE)
germany = readr::read_csv('../data/raw/Germany_Fusball_Bundesliga_2018-19.csv', show_col_types = FALSE)
greece = readr::read_csv('../data/raw/Greece_Super_League_Greece_2018-19.csv', show_col_types = FALSE)
italy = readr::read_csv('../data/raw/Italy_Serie_A_2018-19.csv', show_col_types = FALSE)
nether = readr::read_csv('../data/raw/Netherlands_Eredivise_2018-19.csv', show_col_types = FALSE)
portugal = readr::read_csv('../data/raw/Portugal_Premeira_Liga_2018-19.csv', show_col_types = FALSE)
russia = readr::read_csv('../data/raw/Russia_Russian_Premier_League_2018-19.csv', show_col_types = FALSE)
serbia = readr::read_csv('../data/raw/Serbia_Serbian_SuperLiga_2018-19.csv', show_col_types = FALSE)
spain = readr::read_csv('../data/raw/Spain_La_Liga_2018-19.csv', show_col_types = FALSE)
turkey = readr::read_csv('../data/raw/Turkiye_Super_Lig_2018-19.csv', show_col_types = FALSE)
ukraine = readr::read_csv('../data/raw/Ukraine_Ukrainian_Premier_League_2018-19.csv', show_col_types = FALSE)
```

## Data Pre-processing

In order to use the domestic competition and UEFA Champions League matchup data scraped from [fbref.com](https://www.fbref.com/)[^2] with the Bradley-Terry package, `BradleyTerry2`, the raw data must first be cleaned, parsed, and reformated into the package's expected format. This code follows that found in Lecture 12 [@lecture12], particularly when refactoring home and away win data into a trainable DataFrame.

[^2]: Specific links and FBRef pages used can be found in the *GettingRawMatchupData.Rmd* notebook.

```{r}
# Helper to remove xG columns from relevant leagues so all competitions have the same number of columns
remove_xg = function(df){ 
  if((df %>% select(contains('_xG')) %>% length()) > 0){
    return(df %>% select(-contains('_xG')))
  }
  else {
    return(df)
  }
}
austria = remove_xg(austria)
belgium = remove_xg(belgium)
croatia = remove_xg(croatia)
czech = remove_xg(czech)
england = remove_xg(england)
france = remove_xg(france)
germany = remove_xg(germany)
greece = remove_xg(greece)
italy = remove_xg(italy)
nether = remove_xg(nether)
portugal = remove_xg(portugal)
russia = remove_xg(russia)
serbia = remove_xg(serbia)
spain = remove_xg(spain)
turkey = remove_xg(turkey)
ukraine = remove_xg(ukraine)
```

```{r}
# Concatenate all leagues together
all = austria %>%
  rbind(belgium) %>%
  rbind(croatia) %>%
  rbind(czech) %>%
  rbind(england) %>%
  rbind(france) %>%
  rbind(germany) %>%
  rbind(greece) %>%
  rbind(italy) %>%
  rbind(nether) %>%
  rbind(portugal) %>%
  rbind(russia) %>%
  rbind(serbia) %>%
  rbind(spain) %>%
  rbind(turkey) %>%
  rbind(ukraine)
all %>% head(10)
```

With the leagues all concatenated together, we can check to see the distribution of the complete DataFrame's members.

```{r, echo=FALSE}
set.seed(25)
all[sample(1:nrow(all), size=10),]
```

```{r, echo = FALSE}
matches_by_country = all %>%
  group_by(Country) %>%
  count(.drop = TRUE)

plot = ggplot2::ggplot(matches_by_country, aes(x = Country, y = n)) + 
  ggplot2::geom_col() + 
  labs(
    title = "2018-19 Domestic League Matches By Competing Nation",
    x = "UEFA Country",
    y = "Number of Matches"
  ) +
  ggplot2::theme_minimal()  # clean built-in ggplot2 theme

plot

```

```{r}
# CODE FROM LECTURE 12
# results <-
#  no_ties |>
#  dplyr::rename(home.team = Home, away.team = Opponent) |>
#  dplyr::group_by(home.team, away.team) |>
#  dplyr::summarise(
#    home.win = sum(Home_Winner),
#    away.win = sum(Opp_Winner), .groups = 'drop') |>
#  dplyr::mutate(
#    home.team = factor(home.team, levels = unik_teams),
#    away.team = factor(away.team,levels = unik_teams))
no_ties = all %>% filter(HomeGoals != AwayGoals) %>%
  filter(!str_detect(Round, "play-offs") | is.na(Round)) %>% ## removing matchups in pro/rel playoffs, otherwise we'll see skewed strengths for those leagues
  mutate(Home_Winner = case_when(HomeGoals > AwayGoals ~ 1, .default=0),
         Opp_Winner = case_when(AwayGoals > HomeGoals ~ 1, .default=0))

unik_teams = sort(unique(c(no_ties$Home, no_ties$Away)))

results = no_ties %>% 
  rename(home.team = Home, away.team = Away) %>%
  group_by(home.team, away.team) %>%
  dplyr::summarise(
    home.win = sum(Home_Winner),
    away.win = sum(Opp_Winner), .groups = 'drop') |>
  dplyr::mutate(
    home.team = factor(home.team, levels = unik_teams),
    away.team = factor(away.team, levels = unik_teams))
results[sample(1:nrow(results),size=10),]
```

With the data now in place and formatted for `BradleyTerry2`, we can begin fitting a Bradley-Terry model to determine latent team strength for all clubs competing in the 2019-20 UEFA Champions League group stage based on their domestic league results.

## Fitting Bradley-Terry Model Based on Domestic League Results

For this problem, we'll use the worst performing team in the lowest-rated domestic competition based on the UEFA association club coefficient[^3] for the 2018-19 season, which can be found at [UEFA.com](https://www.uefa.com/nationalassociations/uefarankings/country/?year=2019).

[^3]: <https://en.wikipedia.org/wiki/UEFA_coefficient>

Based on the table below, Greece had the lowest rating of the 16 nations represented by clubs in the 2019-20 tournament.

#### Table: 2018-19 UEFA association club coefficients for competing nations

```{r}
read_csv('../data/raw/League_Participant_Info_2018-19.csv') %>%
  select(full_name, last_association_coef) %>%
  rename(Country = full_name, Coefficient = last_association_coef) %>%
  arrange(desc(Coefficient))
```

In the 2018-19 season of the Greek Super League, *Apollon Smyrnis* finished in last place[^4], so we'll use them as our reference for fitting the Bradley-Terry model.

[^4]: <https://en.wikipedia.org/wiki/2018%E2%80%9319_Super_League_Greece#League_table>

```{r}
fit <-
  BradleyTerry2::BTm(
    outcome = cbind(home.win, away.win),
    player1 = home.team, player2 = away.team,
    refcat = "Yenisey",
    data = results)
summary(fit)
```

```{r}
lambda_hat = as.data.frame(BradleyTerry2::BTabilities(fit))
lambda_hat = lambda_hat %>% drop_na() %>% arrange(desc(ability))
lambda_hat = rownames_to_column(lambda_hat) %>% rename(team = rowname)
lambda_hat
```

Given the summary of the Bradley-Terry model and its resulting team strengths, it seems that the results were relatively sensitive to positive results for teams in skewed competitions. In other words, in leagues that are typically dominated by a small number of teams (Greece, Czechia), results over and by the top teams in the competitions were "rewarded" more than their counterparts in other "fairer" competitions (England, Spain). Subjectively, clubs like Slavia Prague typically due dominant their domestic competition, which means we would expect a high "ability" assignment, like we see in this model.

For the sake of our project, we'll only focus on the strengths of the clubs competing in the 2019-20 UEFA Champions League group stages. From this, we see the aforementioned Slavia Prague leading in "domestic strength", along with other dominant teams from smaller nations, like Olympiacos from Greece and Dinamo Zagreb from Croatia. This aligns with our prior assumptions,

```{r, echo=FALSE}
uefa = read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv') 
uefa = uefa %>% select(Home) %>% mutate(Country = str_extract(uefa$Home, " [a-z]{2,3}$"), Home = str_remove(uefa$Home, " [a-z]{2,3}$")) %>% select(Home, Country, everything())
champs_w_league_ratings = uefa %>% left_join(lambda_hat %>% rename(Home = team)) %>% unique() %>% replace(is.na(.), 0)
champs_w_league_ratings %>% arrange(desc(ability))
```

```{r, echo=FALSE}
strongest = champs_w_league_ratings %>% arrange(desc(ability)) %>% head(5)
plot = ggplot2::ggplot(strongest, aes(Home, ability)) + 
  ggplot2::geom_col() + 
  labs(title = "Top 5 Teams by 2018-19 Domestic Performance Strength", x = "Club", y = "Team Strength λ") + 
  ggplot2::theme_minimal()
plot
```

To calculate Round of 16 results, it wouldn't make sense to only use domestic league coefficients because as we've seen, they are very susceptible to showing one strong team in a weak league. To fix this, for simulating the round of 16 results, we can use the group stage of the UCL to get BT scores for each of the teams that advanced. Domestic results still play a part in the strength, because a 6 game sample where each team didn't end up playing all the others doesn't give us reliable coefficients. So, our strategy was to weight UCL games heavier, and combine those games with domestic league games to get new BT scores which will help simulate the round of 16. 

This code sets up our data where we get the domestic results + group stage results to fit into our BT model.


```{r}
ucl = readr::read_csv('../data/raw/UEFA_Champions_League_2020_Results_RAW.csv', show_col_types = FALSE)
ucl = ucl %>%  
  mutate(
    Country_Away = str_extract(Away, "^[A-Za-z]{2,3}(?=\\s)"),
    Country_Home = str_extract(ucl$Home, " [a-z]{2,3}$")
  ) %>%
  mutate(
    Home = stringr::str_remove(Home, " [a-z]{2,3}$"),
    Away = str_remove(Away, "^[A-Za-z]{2,3}\\s+")
  )

uefa_playoff_teams = ucl %>%
  filter(Round %in% c("Round of 16", "Quarter-finals", "Semi-finals", "Final")) %>% select(Home, Away) %>%
  unlist(use.names = FALSE) %>% unique() 

ucl_group <- ucl %>%
  filter(Round == "Group stage", HomeGoals != AwayGoals)

ucl_teams <- sort(unique(c(ucl_group$Home, ucl_group$Away)))

domestic_restricted <- all %>%
  mutate(Home = as.character(Home), Away = as.character(Away)) %>%
  filter(Home %in% ucl_teams | Away %in% ucl_teams) %>%
  filter(HomeGoals != AwayGoals) %>%
  filter(!stringr::str_detect(Round, "play-offs") | is.na(Round))
wt_ucl = 8
wt_dom = 1

bt_dom <- domestic_restricted %>%
  transmute(
    home.team = Home,
    away.team = Away,
    home.win  = as.integer(HomeGoals > AwayGoals),
    away.win  = as.integer(AwayGoals > HomeGoals),
    Competition = "Domestic"
  )

bt_ucl <- ucl_group %>%
  transmute(
    home.team = Home,
    away.team = Away,
    home.win  = as.integer(HomeGoals > AwayGoals),
    away.win  = as.integer(AwayGoals > HomeGoals),
    Competition = "UCL"
  )

bt_all <- bind_rows(bt_dom, bt_ucl) %>%
  mutate(w = ifelse(Competition == "UCL", wt_ucl, wt_dom))

unik_teams_all <- sort(unique(c(bt_all$home.team, bt_all$away.team)))
bt_all <- bt_all %>%
  mutate(
    home.team = factor(home.team, levels = unik_teams_all),
    away.team = factor(away.team, levels = unik_teams_all)
  )


```


Fitting the BT model, we get:


```{r}
fit_all = BradleyTerry2::BTm(
  outcome = cbind(home.win, away.win),
  player1 = home.team,
  player2 = away.team,
  refcat = "Yenisey", 
  data = bt_all
)

lambda_hat_combined <- BradleyTerry2::BTabilities(fit_all) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("team") %>%
  arrange(desc(ability))

lambda_hat_combined = lambda_hat_combined %>%
  filter(team %in% uefa_playoff_teams)

lambda_hat_combined
```


From the results we see that Juventus, Liverpool, and Barcelona are at the top of the ability category. These teams all had strong rosters and strong domestic results as well as group stage results. At the bottom, as expected we see teams less prestigious like Atalanta and Valencia. The standard error is all the same, which is because since all the teams didn't play each other for example Bayern never played Valencia, so we get disconnected graphs. For this round of 16 simulation, this doesn't make a huge deal.  





Displaying our strengths in a graph:
```{r}

lambda_hat_combined %>% 
  slice_max(ability, n = 10) %>%
  ggplot(aes(reorder(team, ability), ability)) +
  geom_col() + coord_flip() +
  labs(title="Top BT Strengths (Domestic+UCL Group Stage(Group match weights 8x))", x=NULL, y="Ability (β)") +
  theme_minimal()


```

Since the round of 16 for the Champions League Tournament had 2 legs before COVID officially shut down the tournament, we need to simulate both legs of the contest. However our Bradley-Terry model has limitations where it doesn't predict score just the overall winner. For 2 leg contests, this shows a problem where aggregate score decides the winner. If both teams win one game, the Bradley Terry model doesn't know who wins the whole round. Also, if one team wins marginally, and the other team wins by a lot, it still looks like 1 win and 1 loss to the Bradley Terry model. This is the reason that we want to get the scores of the matchups, so we shift for this round specifically to a Markov Chain model modeling states of the games using the Bradley-Terry strengths to simulate goal scores and state changes.

```{r}
total_gpm <- 2.7   # constant, estimated how many goals are scored per game
beta      <- 0.9   # how strongly BT ability difference tilts scoring share
hfa       <- 0.28  # home-field advantage in the scoring-share logit
et_scale  <- 0.75  # scoring slows in extra time
set.seed(25)

inv_logit <- function(x) 1/(1+exp(-x))

lambda_vec_raw <- setNames(lambda_hat_combined$ability, lambda_hat_combined$team)

get_lambda <- function(team) {#helper to get BT scores
  if (!is.na(team) && team %in% names(lambda_vec_raw)) {
    lambda_vec_raw[[team]]
  } else {
    0
  }
}

r16_ties <- tibble::tribble(
  ~tie_id, ~home_first_leg,     ~away_first_leg,
  "R16-1", "Atalanta",          "Valencia",
  "R16-2", "Dortmund",          "Paris S-G",
  "R16-3", "Atletico Madrid",   "Liverpool",
  "R16-4", "Tottenham",         "RB Leipzig",
  "R16-5", "Chelsea",           "Bayern Munich",
  "R16-6", "Napoli",            "Barcelona",
  "R16-7", "Real Madrid",       "Manchester City",
  "R16-8", "Lyon",              "Juventus"
)


r16_ties

```

```{r}
sim_match_markov <- function(Home, Away, neutral=FALSE, allow_et=TRUE) {
  lamH <- get_lambda(Home); lamA <- get_lambda(Away)
  r_tot <- total_gpm / 90   # goal p per min
  s_home <- inv_logit(beta * (lamH - lamA) + ifelse(neutral, 0, hfa))
  pH <- r_tot * s_home
  pA <- r_tot * (1 - s_home)
  #first 90 mins
  gH <- 0L; gA <- 0L
  for (t in 1:90) {
    u <- runif(1)
    if (u < pH) gH <- gH + 1L else if (u < pH + pA) gA <- gA + 1L
  }
  
  #extra time - scale p to show scoring in ET
  if (allow_et && gH == gA) {
    pH_et <- pH * et_scale; pA_et <- pA * et_scale
    for (t in 1:30) {
      u <- runif(1)
      if (u < pH_et) gH <- gH + 1L else if (u < pH_et + pA_et) gA <- gA + 1L
    }
    if (gH == gA) {
      # Penalties 
      base <- 0.76; tilt <- 0.02 #tilt nudges odds towards stronger team
      p_home <- max(min(base + tilt * tanh(lamH - lamA), 0.95), 0.55)
      p_away <- max(min(base - tilt * tanh(lamH - lamA), 0.95), 0.55)
      a <- b <- 0L
      for (i in 1:5) { a <- a + rbinom(1,1,p_home); b <- b + rbinom(1,1,p_away) }
      if (a != b) return(list(gH=gH, gA=gA, mode="PK", winner=ifelse(a>b,"home","away")))
      repeat {
        aa <- rbinom(1,1,p_home); bb <- rbinom(1,1,p_away)
        if (aa != bb) return(list(gH=gH, gA=gA, mode="PK", winner=ifelse(aa>bb,"home","away")))
      }
    }
    return(list(gH=gH, gA=gA, mode="ET", winner=ifelse(gH>gA,"home","away")))
  }
  list(gH=gH, gA=gA, mode="FT", winner=ifelse(gH>gA,"home","away"))
}

```

```{r}
sim_two_leg_markov <- function(A, B, away_goals_rule=TRUE) {
  # Leg 1: A home
  L1 <- sim_match_markov(A, B, neutral=FALSE, allow_et=FALSE)
  # Leg 2: B home
  L2 <- sim_match_markov(B, A, neutral=FALSE, allow_et=FALSE)

  aggA <- L1$gH + L2$gA
  aggB <- L1$gA + L2$gH
  if (aggA != aggB) return(list(winner=ifelse(aggA>aggB, A, B),
                                aggA=aggA, aggB=aggB, decided="AGG"))
  if (away_goals_rule) {
    A_away <- L2$gA; B_away <- L1$gA
    if (A_away != B_away)
      return(list(winner=ifelse(A_away>B_away, A, B),
                  aggA=aggA, aggB=aggB, decided="AWAY_GOALS"))
  }
  # ET in Leg 2 (B home)
  lamB <- get_lambda(B); lamA <- get_lambda(A)
  r_tot <- total_gpm / 90
  s_home <- inv_logit(beta * (lamB - lamA) + hfa)
  pH_et <- (r_tot * s_home) * et_scale
  pA_et <- (r_tot * (1 - s_home)) * et_scale
  gH_et <- 0L; gA_et <- 0L
  for (t in 1:30) {
    u <- runif(1)
    if (u < pH_et) gH_et <- gH_et + 1L else if (u < pH_et + pA_et) gA_et <- gA_et + 1L
  }
  aggA2 <- aggA + gA_et
  aggB2 <- aggB + gH_et
  if (aggA2 != aggB2)
    return(list(winner=ifelse(aggA2>aggB2, A, B),
                aggA=aggA2, aggB=aggB2, decided="ET"))

  # PKs
  base <- 0.76; tilt <- 0.02
  p_home <- max(min(base + tilt * tanh(lamB - lamA), 0.95), 0.55)
  p_away <- max(min(base - tilt * tanh(lamB - lamA), 0.95), 0.55)
  a <- b <- 0L
  for (i in 1:5) { a <- a + rbinom(1,1,p_home); b <- b + rbinom(1,1,p_away) }
  if (a != b) return(list(winner=ifelse(a>b, B, A),
                          aggA=aggA2, aggB=aggB2, decided="PK"))
  repeat {
    aa <- rbinom(1,1,p_home); bb <- rbinom(1,1,p_away)
    if (aa != bb) return(list(winner=ifelse(aa>bb, B, A),
                              aggA=aggA2, aggB=aggB2, decided="PK"))
  }
}
```

```{r}
simulate_r16_mc <- function(N=5000, away_goals_rule=TRUE) {
  purrr::map_dfr(seq_len(nrow(r16_ties)), function(i) {
    A <- r16_ties$home_first_leg[i]
    B <- r16_ties$away_first_leg[i]
    winsA <- 0L; sumAggA <- 0; sumAggB <- 0
    for (k in 1:N) {
      out <- sim_two_leg_markov(A, B, away_goals_rule=away_goals_rule)
      if (out$winner == A) winsA <- winsA + 1L
      sumAggA <- sumAggA + out$aggA
      sumAggB <- sumAggB + out$aggB
    }
    pA <- winsA / N
    tibble::tibble(
      tie_id = r16_ties$tie_id[i],
      team_A = A, team_B = B,
      p_adv_A = pA,
      p_adv_B = 1 - pA,
      se_A = sqrt(pA*(1-pA)/N),
      mean_agg_A = sumAggA / N,
      mean_agg_B = sumAggB / N
    )
  }) %>% arrange(tie_id)
}
```


From our games, we decided to run a markov simulation to get the probability a team will win out of N times, which also gets the average aggregate scores between two teams. This shows us in a real simulation how many times a team would be expected to win based on our BT strengths, and the matchup. 


```{r}
N <- 5000
r16_results <- simulate_r16_mc(N=N, away_goals_rule=TRUE)
print(r16_results)
```

From the Monte Carlo results, we see that:
 - Atalanta is favored over Valencia slightly, reflecting Atalanta's win in real life. 
 - Dortmund is heavily favored over PSG, which was wrong by the model, the BT including the group stage ranked PSG very low which was interesting
 - Liverpool is heavily favored over Atletico Madrid, similar to real life where an upset happened and Atletico Madrid pulled out the victory
 - Leipzig is favored 0.7 to 0.3 to Tottenham, aligning with real life
 - Bayern is favored 0.8 to 0.2, aligning with real life where Bayern won
 - Barcelona is favored 0.7 to 0.3 to Napoli, where Barcelona pulled out the win
 - Manchester City was heavily favored against Real Madrid, 0.9 to 0.1 where Manchester City won in real life
 - With the biggest upset, Lyon won in real life vs Juventus, which is 0.99 percent to win showing a large upset from our model's expectation


```{r}

r16_long <- r16_results %>%
  mutate(matchup = paste(team_A, "vs", team_B)) %>%           # <-- create it
  pivot_longer(
    cols = c(mean_agg_A, mean_agg_B),
    names_to = "which_team",
    values_to = "mean_goals"
  ) %>%
  mutate(team = if_else(which_team == "mean_agg_A", team_A, team_B)) %>%
  select(tie_id, matchup, team, mean_goals)



# Plot: side-by-side bars per matchup
ggplot(r16_long, aes(x = matchup, y = mean_goals, fill = team)) +
  geom_col(position = position_dodge(width = 0.7), width = 0.6) +
  geom_text(aes(label = round(mean_goals, 2)),
            position = position_dodge(width = 0.7),
            vjust = -0.25, size = 3) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.08))) +
  labs(title = "R16: Average Goals by Team (Markov simulations)",
       x = "Matchup", y = "Average Goals", fill = "Team") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 25, hjust = 1))

```

```{r}
r16_long <- r16_results %>%
  transmute(
    tie_id,
    team_A, team_B,
    p_A = p_adv_A,
    p_B = p_adv_B
  ) %>%
  pivot_longer(cols = c(team_A, team_B),
               names_to = "side", values_to = "team") %>%
  mutate(prob = ifelse(side == "team_A", p_A, p_B)) %>%
  mutate(prob_cap50 = pmin(prob, 0.5),
         label_full = sprintf("%.1f%%", 100 * prob))


ggplot(r16_long, aes(x = tie_id, y = prob_cap50, fill = team)) +
  geom_col(position = position_dodge(width = 0.65), width = 0.6) +
  geom_text(aes(label = label_full),
            position = position_dodge(width = 0.65),
            vjust = -0.25, size = 3.2) +
  scale_y_continuous(labels = percent_format(accuracy = 1),
                     limits = c(0, 0.5), breaks = seq(0, 0.5, by = 0.1)) +
  labs(
    title = "R16: Win Probabilities (Each Team Capped at 50%)",
    x = "Tie",
    y = "Probability (capped at 50%)",
    fill = "Team"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

```


```{r}

#helper to simulate match using markov function
play_neutral <- function(A, B) {
  out <- sim_match_markov(Home = A, Away = B, neutral = TRUE, allow_et = TRUE)
  if (out$winner == "home") A else B
}

simulate_tournament_once <- function(r16_results) {
  winners_r16 <- r16_results %>%
    arrange(tie_id) %>%                 
    mutate(
      A_wins = runif(n()) < p_adv_A,
      winner = ifelse(A_wins, team_A, team_B)
    )

  qf1_A <- winners_r16$winner[winners_r16$tie_id == "R16-1"]
  qf1_B <- winners_r16$winner[winners_r16$tie_id == "R16-2"]

  qf2_A <- winners_r16$winner[winners_r16$tie_id == "R16-3"]
  qf2_B <- winners_r16$winner[winners_r16$tie_id == "R16-4"]

  qf3_A <- winners_r16$winner[winners_r16$tie_id == "R16-5"]
  qf3_B <- winners_r16$winner[winners_r16$tie_id == "R16-6"]

  qf4_A <- winners_r16$winner[winners_r16$tie_id == "R16-7"]
  qf4_B <- winners_r16$winner[winners_r16$tie_id == "R16-8"]

  qf1_w <- play_neutral(qf1_A, qf1_B)
  qf2_w <- play_neutral(qf2_A, qf2_B)
  qf3_w <- play_neutral(qf3_A, qf3_B)
  qf4_w <- play_neutral(qf4_A, qf4_B)

  
  sf1_w <- play_neutral(qf1_w, qf2_w)
  sf2_w <- play_neutral(qf3_w, qf4_w)

  
  champion <- play_neutral(sf1_w, sf2_w)

  list(
    champion = champion,
    final_A = sf1_w,
    final_B = sf2_w
  )
}

simulate_tournament_field <- function(M = 5000, r16_results) {
  champs   <- character(M)
  finals_A <- character(M)
  finals_B <- character(M)

  for (m in seq_len(M)) {
    sim <- simulate_tournament_once(r16_results)
    champs[m]   <- sim$champion
    finals_A[m] <- sim$final_A
    finals_B[m] <- sim$final_B
  }

  sims <- tibble::tibble(
    sim_id  = seq_len(M),
    champion = champs,
    final_A  = finals_A,
    final_B  = finals_B
  )

  
  title_probs <- sims %>%
    dplyr::count(champion, name = "titles") %>%
    dplyr::mutate(
      total_sims = sum(titles),
      pct = titles / total_sims
    ) %>%
    dplyr::arrange(dplyr::desc(pct))

  final_matchups <- sims %>%
    dplyr::mutate(
      team1 = pmin(final_A, final_B),
      team2 = pmax(final_A, final_B)
    ) %>%
    dplyr::count(team1, team2, name = "n") %>%
    dplyr::mutate(
      total_sims = sum(n),
      pct = n / total_sims
    ) %>%
    dplyr::arrange(dplyr::desc(pct))

  list(
    title_probs    = title_probs,
    final_matchups = final_matchups,
    raw_sims       = sims
  )
}

set.seed(25)
M <- 5000
tourn_out <- simulate_tournament_field(M, r16_results)

tourn_out$title_probs       
tourn_out$final_matchups    
```


## Endnotes {#endnotes}

## References

```{js, echo=FALSE}
$(document).ready(function() {
  $('.footnotes ol').appendTo('#endnotes');
  $('.footnotes').remove();
});
```
